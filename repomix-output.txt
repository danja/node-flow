This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-04-01T16:04:26.186Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Directory Structure
================================================================
.github/
  workflows/
    deploy.yml
src/
  elements/
    base.ts
    container.ts
    interfaces.ts
    text.ts
  markdown/
    entry.ts
    lexicalParser.ts
    markdown.ts
    syntaxParser.ts
    token.ts
  nodes/
    factory.ts
    publisher.ts
    subsystem.ts
  notes/
    note.ts
    subsystem.ts
  pass/
    subsystem.ts
  popups/
    form.ts
    string.ts
  styles/
    box.ts
    canvasTextAlign.ts
    canvasTextBaseline.ts
    cursor.ts
    stroke.ts
    text.ts
    textBox.ts
  types/
    box.ts
    list.ts
    pool.ts
    text.ts
    vector2.ts
  utils/
    color.ts
    html.ts
    math.ts
    string.ts
  widgets/
    button.ts
    color.ts
    factory.ts
    image.ts
    number.ts
    slider.ts
    string.ts
    text.ts
    toggle.ts
    widget.ts
  camera.ts
  connection.ts
  contextMenu.ts
  draggable.ts
  graph.ts
  graphSubsystem.ts
  index.ts
  input.ts
  metadata.ts
  node.ts
  organize.ts
  performance.ts
  popup.ts
  port.ts
  quickMenu.ts
  theme.ts
.gitignore
.npmignore
dev.tsconfig.json
esbuild.ts
index.html
package.json
README.md
tsconfig.json
tsup.config.ts

================================================================
Files
================================================================

================
File: .github/workflows/deploy.yml
================
name: Deployment

concurrency: production

on:
  push:
    branches:
      - main

permissions: 
  contents: write
        
env:
  NODE_VERSION: '18.x'                # set this to the node version to use

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - name: npm install, build, and test
      run: |
        npm install
        npm run build --
        rm -rf node_modules/
    - name: Upload artifact for deployment job
      uses: actions/upload-artifact@v4
      with:
        name: node-app
        path: .

  deploy:
    runs-on: ubuntu-latest
    needs: build
    environment:
      name: 'production'

    steps:
    - name: Download artifact from build job
      uses: actions/download-artifact@v4
      with:
        name: node-app

    - name: Deploy to GitHub Pages
      uses: crazy-max/ghaction-github-pages@v4
      with:
        target_branch: gh-pages
        build_dir: .
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

================
File: src/elements/base.ts
================
import { Vector2 } from "../types/vector2";
import { Border, BorderStyling, InstantiateRenderElementSidesStyling, IRenderElement, RenderElementSides, RenderElementSidesStyling } from "./interfaces";

export enum Display {
    Flex = "flex",
    None = "none"
}

export interface RenderElementBaseStyling {
    Margin?: RenderElementSidesStyling | number;
    Padding?: RenderElementSidesStyling | number;
    Border?: BorderStyling;
    BackgroundColor?: string;
    MinWidth?: number;
    MaxWidth?: number;
    MaxHeight?: number;
    MinHeight?: number;
    Grow?: number;
    Display?: Display;
}

export abstract class RenderElementBase implements IRenderElement {

    #margin: RenderElementSides;

    #padding: RenderElementSides;

    #border: Border;

    #backgroundColor?: string;

    #minWidth?: number;

    #maxWidth?: number;

    #minHeight?: number;

    #maxHeight?: number;

    #grow?: number;

    #display: Display;

    constructor(config?: RenderElementBaseStyling) {
        this.#margin = InstantiateRenderElementSidesStyling(config?.Margin);
        this.#padding = InstantiateRenderElementSidesStyling(config?.Padding);
        this.#backgroundColor = config?.BackgroundColor;
        this.#border = {
            Color: config?.Border?.Color ?? "black",
            Thickness: config?.Border?.Thickness ?? 0,
            Radius: config?.Border?.Radius ?? 0,
        }
        this.#minWidth = config?.MinWidth;
        this.#maxWidth = config?.MaxWidth;
        this.#minHeight = config?.MinHeight;
        this.#maxHeight = config?.MaxHeight;
        this.#grow = config?.Grow;
        this.#display = config?.Display ?? Display.Flex;
    }

    setBackgroundColor(newColor: string): void {
        this.#backgroundColor = newColor;
    }

    abstract doRender(ctx: CanvasRenderingContext2D, position: Vector2, graphScale: number, scaledFillableSpace: Vector2): void;

    render(ctx: CanvasRenderingContext2D, position: Vector2, graphScale: number, scaledFillableSpace: Vector2): void {
        if (this.#display === Display.None) {
            return;
        }

        const scaledSize = { x: 0, y: 0 };
        this.size(ctx, scaledSize);

        scaledSize.x = scaledSize.x * graphScale;
        scaledSize.y = scaledSize.y * graphScale;
        scaledSize.x = Math.max(scaledSize.x, scaledFillableSpace.x);
        scaledSize.y = Math.max(scaledSize.y, scaledFillableSpace.y);

        if (this.#backgroundColor) {
            ctx.fillStyle = this.#backgroundColor;
            ctx.beginPath();
            ctx.roundRect(
                position.x + (this.#margin.Left * graphScale),
                position.y + (this.#margin.Right * graphScale),
                scaledSize.x - ((this.#margin.Left + this.#margin.Right) * graphScale),
                scaledSize.y - ((this.#margin.Top + this.#margin.Bottom) * graphScale),
                this.#border.Radius * graphScale
            );
            ctx.fill();
        }

        if (this.#border.Thickness > 0) {
            ctx.lineWidth = this.#border.Thickness * graphScale;
            ctx.strokeStyle = this.#border.Color;
            ctx.stroke();
        }

        const offsetPosition = {
            x: position.x + (this.#totalLeftOffset() * graphScale),
            y: position.y + (this.#totalTopOffset() * graphScale),
        };
        const elementSize = {
            x: scaledSize.x - (this.#horizontalOffset() * graphScale),
            y: scaledSize.y - (this.#verticalOffset() * graphScale)
        }
        this.doRender(ctx, offsetPosition, graphScale, elementSize);
    }

    abstract calcSize(ctx: CanvasRenderingContext2D, out: Vector2, limitations: Vector2): void;

    protected maxLimitations(out: Vector2): void {
        out.x = -1;
        out.y = -1;

        if (this.#maxWidth) {
            out.x = this.#maxWidth;
        }

        if (this.#maxHeight) {
            out.y = this.#maxHeight;
        }
    }

    setDisplay(display: Display): void {
        this.#display = display;
    }

    getDisplay(): Display {
        return this.#display;
    }

    size(ctx: CanvasRenderingContext2D, out: Vector2): void {
        out.x = 0;
        out.y = 0;
        if (this.#display === Display.None) {
            return;
        }

        const maxLimits = { x: -1, y: -1 }
        this.maxLimitations(maxLimits);

        this.calcSize(ctx, out, maxLimits);

        out.x += this.#horizontalOffset();
        out.y += this.#verticalOffset();

        if (this.#minWidth) {
            out.x = Math.max(out.x, this.#minWidth)
        }

        if (this.#maxWidth) {
            out.x = Math.min(this.#maxWidth, out.x);
        }

        if (this.#maxHeight) {
            out.y = Math.min(this.#maxHeight, out.y);
        }

        if (this.#minHeight) {
            out.y = Math.max(this.#minHeight, out.y);
        }
    }

    #horizontalOffset(): number {
        return (this.#border.Thickness) +
            this.#margin.Left +
            this.#margin.Right +
            this.#padding.Left +
            this.#padding.Right;
    }

    #verticalOffset(): number {
        return (this.#border.Thickness) +
            this.#margin.Top +
            this.#margin.Bottom +
            this.#padding.Top +
            this.#padding.Bottom;
    }

    #totalTopOffset(): number {
        return (this.#border.Thickness / 2) +
            this.#margin.Top +
            this.#padding.Top;
    }

    #totalLeftOffset(): number {
        return (this.#border.Thickness / 2) +
            this.#margin.Left +
            this.#padding.Left;
    }
}

================
File: src/elements/container.ts
================
import { ScaleVector, Vector2 } from '../types/vector2';
import { RenderElementBase, RenderElementBaseStyling } from "./base";
import { IRenderElement } from "./interfaces";


interface ContainerRenderElementConfig extends RenderElementBaseStyling {

}

export enum LayoutDirection {
    Column = "column",
    Row = "row"
}

export enum AlignItems {
    Stretch = "stretch",
    Start = "start",
    Center = "center",
    End = "end"
}

export class ContainerRenderElement extends RenderElementBase {

    #elements: Array<IRenderElement>;

    #layout: LayoutDirection;

    #alignment: AlignItems;

    constructor(elements: Array<IRenderElement>, config?: ContainerRenderElementConfig) {
        super(config);
        this.#elements = elements;
        this.#layout = LayoutDirection.Column;
        this.#alignment = AlignItems.Stretch;
    }

    calcSize(ctx: CanvasRenderingContext2D, out: Vector2, limitations: Vector2): void {
        out.x = 0;
        out.y = 0;

        const eleSize = { x: 0, y: 0 };

        switch (this.#layout) {
            case LayoutDirection.Column:
                for (let i = 0; i < this.#elements.length; i++) {
                    this.#elements[i].size(ctx, eleSize);
                    out.x = Math.max(out.x, eleSize.x);
                    out.y += eleSize.y;
                }
                break;

            case LayoutDirection.Row:
                for (let i = 0; i < this.#elements.length; i++) {
                    this.#elements[i].size(ctx, eleSize);
                    out.y = Math.max(out.y, eleSize.y);
                    out.x += eleSize.x;
                }
                break;

            default:
                throw new Error("unknown layout: " + this.#layout);
        }

    }

    doRender(ctx: CanvasRenderingContext2D, position: Vector2, graphScale: number, scaledFillableSpace: Vector2): void {
        // const size = { x: 0, y: 0 };
        // const limitations = { x: 0, y: 0 };
        // this.limitations(limitations)
        // this.calcSize(ctx, size, limitations);
        switch (this.#layout) {
            case LayoutDirection.Column:
                this.#renderColumn(ctx, position, graphScale, scaledFillableSpace);
                break;

            default:
                throw new Error("unimplemented layout direction: " + this.#layout);
        }
    }

    #renderColumn(ctx: CanvasRenderingContext2D, position: Vector2, graphScale: number, scaledFillableSpace: Vector2): void {
        const currnetPos = { x: position.x, y: position.y };
        const scaledEleSize = { x: 0, y: 0 };
        for (let i = 0; i < this.#elements.length; i++) {
            const ele = this.#elements[i];

            ele.size(ctx, scaledEleSize);
            ScaleVector(scaledEleSize, graphScale);

            switch (this.#alignment) {

                case AlignItems.Stretch:
                    currnetPos.x = position.x;
                    scaledEleSize.x = scaledFillableSpace.x;
                    break;

                // I'm not sure if this is even needed, I feel like this should
                // already be the case.
                case AlignItems.Start: //garney flarney <---- silly goose steenky feet
                    currnetPos.x = position.x;
                    break

                case AlignItems.End:
                    currnetPos.x = scaledFillableSpace.x - scaledEleSize.x
                    break;

                case AlignItems.Center:
                    currnetPos.x = scaledFillableSpace.x - (scaledEleSize.x / 2)
                    break;

                default:
                    throw new Error("unimplmeneted alignment: " + this.#alignment)
            }

            ele.render(ctx, currnetPos, graphScale, scaledEleSize);
            currnetPos.y += scaledEleSize.y;
        }
    }
}

================
File: src/elements/interfaces.ts
================
import { Vector2 } from "../types/vector2"


export interface RenderElementSidesStyling {
    Left?: number
    Right?: number
    Top?: number
    Bottom?: number
}

export interface RenderElementSides {
    Left: number
    Right: number
    Top: number
    Bottom: number
}

export function InstantiateRenderElementSidesStyling(config?: RenderElementSidesStyling | number): RenderElementSides {
    if (typeof config === 'number') {
        return {
            Bottom: config,
            Right: config,
            Top: config,
            Left: config,
        }
    }
    return {
        Bottom: config?.Bottom === undefined ? 0 : config?.Bottom,
        Right: config?.Right === undefined ? 0 : config?.Right,
        Left: config?.Left === undefined ? 0 : config?.Left,
        Top: config?.Top === undefined ? 0 : config?.Top,
    }
}

export interface IRenderElement {
    size(ctx: CanvasRenderingContext2D, out: Vector2): void;
    render(ctx: CanvasRenderingContext2D, position: Vector2, graphScale: number, scaledFillableSpace: Vector2): void;
}

export interface Border {
    Color: string;
    Thickness: number;
    Radius: number;
}

export interface BorderStyling {
    Color?: string;
    Thickness?: number;
    Radius?: number;
}

================
File: src/elements/text.ts
================
import { Text } from "../types/text";
import { CopyVector2, ScaleVector, Vector2, Zero } from "../types/vector2";
import { RenderElementBase, RenderElementBaseStyling } from "./base";

export enum TextAlign {
    Left = "left",
    Right = "right",
    Center = "center",
}

export enum VerticalAlign {
    Top = "top",
    Center = "center",
    Bottom = "bottom"
}

export interface TextElementStyling extends RenderElementBaseStyling {
    Align?: TextAlign
    VerticalAlign?: VerticalAlign
}

export class TextElement extends RenderElementBase {
    #text: Text;

    #align: TextAlign;

    #verticalAlign: VerticalAlign;

    constructor(text: Text, styling?: TextElementStyling) {
        super(styling);
        this.#text = text;
        this.#align = styling?.Align ?? TextAlign.Left;
        this.#verticalAlign = styling?.VerticalAlign ?? VerticalAlign.Top;
    }

    doRender(ctx: CanvasRenderingContext2D, position: Vector2, graphScale: number, scaledFillableSpace: Vector2): void {
        const scale = Zero();
        this.calcSize(ctx, scale);
        ScaleVector(scale, graphScale);

        const justifiedPosition = Zero();
        CopyVector2(justifiedPosition, position)

        ctx.textAlign = "left";
        ctx.textBaseline = "top"

        switch (this.#align) {
            case TextAlign.Left:
                // Do nothing. This is default
                break;

            case TextAlign.Right:
                justifiedPosition.x += scaledFillableSpace.x - scale.x;
                break;

            case TextAlign.Center:
                justifiedPosition.x += (scaledFillableSpace.x - scale.x) / 2;
                break;

            default:
                throw new Error("unimplemented justification: " + this.#align);
        }

        switch (this.#verticalAlign) {
            case VerticalAlign.Top:
                // Do nothing. This is default
                break;

            case VerticalAlign.Bottom:
                justifiedPosition.y += scaledFillableSpace.y - scale.y;
                break;

            case VerticalAlign.Center:
                justifiedPosition.y += (scaledFillableSpace.y - scale.y) / 2;
                break;

            default:
                throw new Error("unimplemented justification: " + this.#align);
        }
        this.#text.render(ctx, graphScale, justifiedPosition);
    }

    calcSize(ctx: CanvasRenderingContext2D, out: Vector2): void {
        this.#text.size(ctx, 1, out);
    }
}

================
File: src/markdown/entry.ts
================
import { Theme } from "../theme";
import { List } from "../types/list";
import { Text } from "../types/text";
import { CopyVector2, Vector2, Zero } from "../types/vector2";

export interface MarkdownEntry {
    render(ctx: CanvasRenderingContext2D, position: Vector2, scale: number, maxWidth: number): number
}

export class CodeBlockEntry {

    #text: Text

    #calculatedPositions: List<Vector2>

    #calculatedEntries: List<Text>

    #calculatedForWidth: number;

    constructor(text: Text) {
        this.#text = text;
        this.#calculatedForWidth = -1

        this.#calculatedEntries = new List<Text>();
        this.#calculatedPositions = new List<Vector2>();

        document.fonts.addEventListener("loadingdone", (event) => {
            this.#calculatedForWidth = -1
        });
    }

    #calculateLayout(ctx: CanvasRenderingContext2D, maxWidth: number): void {
        if (this.#calculatedForWidth === maxWidth) {
            return;
        }

        let adjustedWith = maxWidth;
        adjustedWith -= Theme.Note.CodeBlock.Padding * 2;

        this.#calculatedEntries.Clear();
        this.#calculatedPositions.Clear();

        let curHeight = 0;
        const lineInc = this.#text.style().getSize() + Theme.Note.LineSpacing;

        let entries = this.#text.split("\n")

        for (let entryIndex = 0; entryIndex < entries.length; entryIndex++) {
            const entry = entries[entryIndex];

            let lines = entry.breakIntoLines(ctx, adjustedWith);
            for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {

                this.#calculatedEntries.Push(lines[lineIndex])
                this.#calculatedPositions.Push({
                    x: 0,
                    y: curHeight,
                })
                
                curHeight += lineInc;
            }
        }

        this.#calculatedForWidth = maxWidth;
    }

    render(ctx: CanvasRenderingContext2D, position: Vector2, scale: number, maxWidth: number): number {
        this.#calculateLayout(ctx, maxWidth);

        let padding = Theme.Note.CodeBlock.Padding * scale;

        let max = 0;
        for (let i = 0; i < this.#calculatedEntries.Count(); i++) {
            const pos = this.#calculatedPositions.At(i);
            max = Math.max(max, pos.y * scale)
        }

        const y = position.y + max + (scale * 5)
        ctx.fillStyle = Theme.Note.CodeBlock.BackgroundColor;
        ctx.beginPath();
        ctx.roundRect(
            position.x,
            position.y,
            maxWidth * scale,
            max + (padding * 2),
            Theme.Note.CodeBlock.BorderRadius * scale
        );
        ctx.fill();


        for (let i = 0; i < this.#calculatedEntries.Count(); i++) {
            const entry = this.#calculatedEntries.At(i);
            const pos = this.#calculatedPositions.At(i);

            entry.render(ctx, scale, {
                x: (pos.x * scale) + position.x + padding,
                y: (pos.y * scale) + position.y + padding
            });

            max = Math.max(max, pos.y * scale)
        }


        return max + (padding * 2);
    }
}

export class UnorderedListMarkdownEntry {

    #entries: Array<BasicMarkdownEntry>;

    constructor(entries: Array<BasicMarkdownEntry>) {
        this.#entries = entries;
    }

    render(ctx: CanvasRenderingContext2D, position: Vector2, scale: number, maxWidth: number): number {
        let offset = 0;
        let shift = 20;

        let pos = {
            x: position.x + (shift * scale),
            y: position.y
        }

        let dot = Theme.Note.DotSize * scale;

        for (let i = 0; i < this.#entries.length; i++) {

            ctx.beginPath();
            ctx.arc(position.x + dot, pos.y + (dot * 3), dot, 0, 2 * Math.PI);
            ctx.fill();

            offset += this.#entries[i].render(ctx, pos, scale, maxWidth - shift) + (scale * Theme.Note.LineSpacing * 2);
            pos.y = position.y + offset;
        }

        return offset;
    }
}

export class BasicMarkdownEntry {

    #underline: boolean;

    #background: boolean;

    #entries: Array<Text>

    #calculatedPositions: List<Vector2>

    #calculatedEntries: List<Text>

    #calculatedForWidth: number;

    constructor(lines: Array<Text>, underline: boolean, background: boolean) {
        this.#entries = lines;
        this.#underline = underline;
        this.#background = background;
        this.#calculatedForWidth = -1

        this.#calculatedEntries = new List<Text>();
        this.#calculatedPositions = new List<Vector2>();

        document.fonts.addEventListener("loadingdone", (event) => {
            this.#calculatedForWidth = -1
        });
    }

    #calculateLayout(ctx: CanvasRenderingContext2D, maxWidth: number): void {
        if (this.#calculatedForWidth === maxWidth) {
            return;
        }

        let adjustedWith = maxWidth;
        if (this.#background) {
            adjustedWith -= Theme.Note.CodeBlock.Padding * 2;
        }

        this.#calculatedEntries.Clear();
        this.#calculatedPositions.Clear();

        const curPosition: Vector2 = Zero();
        const texSize: Vector2 = Zero();

        let currentLineHeight = 0;
        const currentLineText = new List<Text>();
        const currentLineWidths = new List<number>();

        for (let entryIndex = 0; entryIndex < this.#entries.length; entryIndex++) {
            const entry = this.#entries[entryIndex];

            let lines = entry.splitAtWidth(ctx, adjustedWith - curPosition.x);
            let i = 0;
            while (lines.length > 1 && i < 100) {
                i++

                // We can't collapse this thing any further. Break out of the 
                // while loop before we have infinite loop on our hands
                // if (lines[0].get() === "" && lines[1].get().length === 1) {
                //     lines[0] = lines[1];
                //     break;
                // }

                // We can't collapse this thing any further. Break out of the 
                // while loop before we have infinite loop on our hands
                if (lines[0].get() === "" && currentLineText.Count() === 0) {

                    if (lines[1].get().length === 1) {
                        lines[0] = lines[1];
                        break;
                    } else {
                        lines = lines[1].splitAtIndex(1);
                    }

                }

                // This effectiviely finishes off the line we're currenly working on.
                if (lines[0].get() !== "") {
                    lines[0].size(ctx, 1, texSize);
                    currentLineHeight = Math.max(currentLineHeight, texSize.y);

                    currentLineText.Push(lines[0]);
                    currentLineWidths.Push(curPosition.x);
                }

                curPosition.y += currentLineHeight;

                // Take everything we're working with and finalize it
                for (let i = 0; i < currentLineText.Count(); i++) {
                    this.#calculatedEntries.Push(currentLineText.At(i));
                    this.#calculatedPositions.Push({ x: currentLineWidths.At(i), y: curPosition.y })
                }

                currentLineText.Clear();
                currentLineWidths.Clear();

                curPosition.y += Theme.Note.LineSpacing;
                currentLineHeight = 0;
                curPosition.x = 0;

                lines = lines[1].splitAtWidth(ctx, adjustedWith);
            }
            if (i === 100) {
                console.log(lines)
            }

            lines[0].size(ctx, 1, texSize);
            currentLineHeight = Math.max(currentLineHeight, texSize.y)

            currentLineText.Push(lines[0]);
            currentLineWidths.Push(curPosition.x);

            curPosition.x += texSize.x;
        }

        curPosition.y += currentLineHeight;

        // Take everything we're working with and finalize it
        for (let i = 0; i < currentLineText.Count(); i++) {
            this.#calculatedEntries.Push(currentLineText.At(i));
            this.#calculatedPositions.Push({ x: currentLineWidths.At(i), y: curPosition.y })
        }

        this.#calculatedForWidth = maxWidth;
    }

    render(ctx: CanvasRenderingContext2D, position: Vector2, scale: number, maxWidth: number): number {
        this.#calculateLayout(ctx, maxWidth);

        let padding = 0;
        if (this.#background) {
            padding += Theme.Note.CodeBlock.Padding * scale;
        }


        if (this.#background) {
            let max = 0;
            for (let i = 0; i < this.#calculatedEntries.Count(); i++) {
                const pos = this.#calculatedPositions.At(i);
                max = Math.max(max, pos.y * scale)
            }

            const y = position.y + max + (scale * 5)
            ctx.fillStyle = Theme.Note.CodeBlock.BackgroundColor;
            ctx.beginPath();
            ctx.roundRect(
                position.x,
                position.y,
                maxWidth * scale,
                max + (padding * 2),
                Theme.Note.CodeBlock.BorderRadius * scale
            );
            ctx.fill();
        }


        let max = 0;
        for (let i = 0; i < this.#calculatedEntries.Count(); i++) {
            const entry = this.#calculatedEntries.At(i);
            const pos = this.#calculatedPositions.At(i);

            entry.render(ctx, scale, {
                x: (pos.x * scale) + position.x + padding,
                y: (pos.y * scale) + position.y + padding
            });

            max = Math.max(max, pos.y * scale)
        }

        // Add underline 
        if (this.#underline) {
            const y = position.y + max + (scale * 5)
            ctx.strokeStyle = Theme.Note.FontColor;
            ctx.lineWidth = Theme.Note.HeaderLineWidth * scale;
            ctx.beginPath();
            ctx.moveTo(position.x, y);
            ctx.lineTo(position.x + (maxWidth * scale), y);
            ctx.stroke();
        }

        return max + (padding * 2);
    }
}

================
File: src/markdown/lexicalParser.ts
================
import { MarkdownToken, MarkdownTokenType } from "./token";

export class MarkdownLexicalParser {

    #body: string;

    #index: number

    #tokens: Array<MarkdownToken>;

    constructor(body: string) {
        this.#index = 0;
        this.#body = body;
        this.#tokens = new Array<MarkdownToken>();
    }

    tokens(): Array<MarkdownToken> {
        return this.#tokens;
    }

    #current(): string {
        if (this.#index > this.#body.length - 1) {
            return ""
        }
        return this.#body.charAt(this.#index);
    }

    #inc(): void {
        this.#index++
    }

    #next(): string {
        this.#index++
        if (this.#index > this.#body.length - 1) {
            return ""
        }
        return this.#body.charAt(this.#index);
    }

    #lastToken = 0;
    
    #addToken(token: MarkdownTokenType, lexeme: string): void {
        this.#tokens.push(new MarkdownToken(token, lexeme, this.#lastToken, this.#index));
        this.#lastToken = this.#index;
    }

    #h2(): void {
        let char = this.#next();
        if (char === "#") {
            this.#addToken(MarkdownTokenType.H3, "###");

            // Move it off the character for the next reading
            this.#inc();
        } else {
            this.#addToken(MarkdownTokenType.H2, "##");
        }
    }

    #h1(): void {
        let char = this.#next();
        if (char === "#") {
            this.#h2();
        } else {
            this.#addToken(MarkdownTokenType.H1, "#");
        }
    }

    #whiteSpace(): void {
        let char = this.#current();

        while (char !== "") {
            if (char !== " " && char !== "\t") {
                break;
            }
            char = this.#next();
        }

        this.#addToken(MarkdownTokenType.Space, " ")
    }

    #text(): void {
        let char = this.#current();

        let started = -1;

        while (char !== "") {
            if (char === " " || char === "\t") {

                // Eat white space if we haven't seen anything yet!
                if (started === -1) {
                    this.#inc();
                    continue;
                }
            }

            // End of the line!
            if (char === "\n" || char === "*" || char === "`") {
                if (started != -1) {
                    this.#addToken(MarkdownTokenType.Text, this.#body.substring(started, this.#index))
                }
                return;
            }


            if (started === -1) {
                started = this.#index;
            }

            char = this.#next();
        }

        if (started != -1) {
            this.#addToken(MarkdownTokenType.Text, this.#body.substring(started, this.#index))
        }
    }

    // S( ) => S
    // S(\t) => S
    // S(#) => H1
    // H1(#) => H2
    // H1(!#) => S
    // H2(#) => H3
    // H2(#) => H3
    parse(): void {
        let char = this.#current();

        while (char !== "") {
            if (char === " " || char === "\t") {
                this.#whiteSpace();
            } else if (char === "#") {
                this.#h1();
            } else if (char === "\n") {
                this.#addToken(MarkdownTokenType.NewLine, "\n");
                this.#inc();
            } else if (char === "*") {
                this.#addToken(MarkdownTokenType.Star, "*");
                this.#inc();
            } else if (char === "`") {
                this.#addToken(MarkdownTokenType.BackTick, "`");
                this.#inc();
            } else {
                this.#text();
            }

            char = this.#current();
        }
    }
}

================
File: src/markdown/markdown.ts
================
import { MarkdownEntry } from "./entry";
import { MarkdownLexicalParser } from "./lexicalParser";
import { MarkdownSyntaxParser } from "./syntaxParser";

export function BuildMarkdown(data: string): Array<MarkdownEntry> {
    const lexicalParser = new MarkdownLexicalParser(data);
    lexicalParser.parse();
    // console.log(lexicalParser.tokens());

    const syntaxParser = new MarkdownSyntaxParser(data, lexicalParser.tokens());
    const contents = syntaxParser.parse()
    // console.log(contents);
    return contents;
}

================
File: src/markdown/syntaxParser.ts
================
import { FontStyle, FontWeight, TextStyleConfig } from "../styles/text";
import { Theme } from "../theme";
import { Text } from "../types/text";
import { BasicMarkdownEntry, CodeBlockEntry, MarkdownEntry, UnorderedListMarkdownEntry } from "./entry";
import { MarkdownToken, MarkdownTokenType } from "./token";

export class MarkdownSyntaxParser {

    #tokens: Array<MarkdownToken>;

    #index: number;

    #originalText: string;

    constructor(originalText: string, tokens: Array<MarkdownToken>) {
        this.#originalText = originalText;
        this.#index = 0;
        this.#tokens = tokens;
    }

    #current(): MarkdownToken | null {
        if (this.#index > this.#tokens.length - 1) {
            return null
        }
        return this.#tokens[this.#index];
    }

    #inc(): void {
        this.#index++
    }

    #next(): MarkdownToken | null {
        this.#index++
        if (this.#index >= this.#tokens.length - 1) {
            return null
        }
        return this.#tokens[this.#index];
    }

    #peak(): MarkdownToken | null {
        if (this.#index + 1 >= this.#tokens.length - 1) {
            return null
        }
        return this.#tokens[this.#index + 1];
    }

    #peakInto(amount: number): MarkdownToken | null {
        if (this.#index + amount >= this.#tokens.length - 1) {
            return null
        }
        return this.#tokens[this.#index + amount];
    }

    #emphasis(): Array<Text> {

        // Cases to consider
        // =================
        // 1.  *a*:      <i>a</i>
        // 2.  **a**:    <b>a</b>
        // 3.  **a*:     *<i>a</i> <----- fuck this one
        // 4.  ***a**:   *<b>a</b> <----- fuck this one
        // 5.  *a**:     <i>a</i>*
        // 6.  **a***:   <b>a</b>*
        // 7.  * a *:    * a *
        // 8.  ** a **:  ** a **
        // 9.  **a **:   **a **
        // 10. **a f**:  <b>a f<b>
        // 11. * Test:   <ul>Test</ul> 

        let token = this.#next();
        if (token?.type() === MarkdownTokenType.Space) {
            return [new Text("*")];
        }

        let bold = false;
        // Read off all leading stars
        while (token !== null && token.type() === MarkdownTokenType.Star) {
            bold = true;
            token = this.#next();
        }

        let textContent = "";

        let boldClosed = false;
        let startingClose = false;
        let validClose = false;
        while (token !== null && token.type() !== MarkdownTokenType.NewLine) {
            if (token.type() === MarkdownTokenType.Star) {

                // This is the second star we've seen in a row. We're done!
                if (startingClose) {
                    boldClosed = true;
                    break;
                }

                // If we're not bold, we just need a single star to close this off.
                startingClose = true;
                if (bold === false) {
                    break;
                }
            }

            if (startingClose && token.type() !== MarkdownTokenType.Star) {
                break;
            }

            // Add to string content...
            if (token.type() === MarkdownTokenType.Text) {
                textContent += token.lexeme();
                validClose = true;
            }

            if (token.type() === MarkdownTokenType.Space) {
                textContent += token.lexeme();
                validClose = false;
            }

            token = this.#next();
        }

        const style: TextStyleConfig = {}

        if (validClose && startingClose) {
            if (boldClosed) {
                style.weight = FontWeight.Bold;
            } else {
                style.style = FontStyle.Italic;
            }
        }

        return [new Text(textContent, style)]
    }

    #text(): Array<Text> {
        let contents: Array<Text> = new Array<Text>();
        let textContent = "";

        let token = this.#current();

        // Read off all starting whitespace 
        while (token !== null && token.type() === MarkdownTokenType.Space) {
            token = this.#next();
        }

        while (token !== null && token.type() !== MarkdownTokenType.NewLine) {
            switch (token.type()) {
                case MarkdownTokenType.Text:
                case MarkdownTokenType.H1:
                case MarkdownTokenType.H2:
                case MarkdownTokenType.H3:
                case MarkdownTokenType.Space:
                    textContent += token.lexeme();
                    break;

                case MarkdownTokenType.Star:
                    if (textContent !== "") {
                        contents.push(new Text(textContent))
                        textContent = "";
                    }
                    let starText = this.#emphasis()
                    for (let i = 0; i < starText.length; i++) {
                        contents.push(starText[i]);
                    }
                    break;
            }

            token = this.#next();
        }

        if (textContent !== "") {
            contents.push(new Text(textContent))
        }

        return contents;
    }

    #h1(): BasicMarkdownEntry {
        // Move off of the header token
        this.#inc();

        const text = this.#text();
        for (let i = 0; i < text.length; i++) {
            text[i].setColor(Theme.Note.FontColor);
            text[i].setSize(Theme.Note.H1.FontSize);
            text[i].setWeight(FontWeight.Bold);
        }

        return new BasicMarkdownEntry(text, true, false);
    }

    #h2(): BasicMarkdownEntry {
        // Move off of the header token
        this.#inc();

        const text = this.#text();
        for (let i = 0; i < text.length; i++) {
            text[i].setColor(Theme.Note.FontColor);
            text[i].setSize(Theme.Note.H2.FontSize);
            text[i].setWeight(FontWeight.Bold);
        }

        return new BasicMarkdownEntry(text, true, false);
    }

    #h3(): BasicMarkdownEntry {
        // Move off of the header token
        this.#inc();

        const text = this.#text();
        for (let i = 0; i < text.length; i++) {
            text[i].setColor(Theme.Note.FontColor);
            text[i].setSize(Theme.Note.H3.FontSize);
            text[i].setWeight(FontWeight.Bold);
        }

        return new BasicMarkdownEntry(text, false, false);
    }

    #starLineStart(): MarkdownEntry {
        if (this.#peak()?.type() !== MarkdownTokenType.Space) {
            const starEntries = this.#text();
            this.#assignStandardStyling(starEntries);
            return new BasicMarkdownEntry(starEntries, false, false);
        }

        // We've begun with a space, which means unordered list!

        const entries = new Array<BasicMarkdownEntry>();

        while (this.#current()?.type() === MarkdownTokenType.Star && this.#peak()?.type() === MarkdownTokenType.Space) {
            this.#inc();
            const starEntries = this.#text();
            this.#assignStandardStyling(starEntries);
            entries.push(new BasicMarkdownEntry(starEntries, false, false));

            // Text reads to the end of the line, which means we're at the new
            // line character. Move forward 1. 
            this.#inc();
        }

        return new UnorderedListMarkdownEntry(entries);

    }

    #assignStandardStyling(textEntries: Array<Text>): void {
        for (let i = 0; i < textEntries.length; i++) {
            textEntries[i].setColor(Theme.Note.FontColor);
            textEntries[i].setSize(Theme.Note.FontSize);
        }
    }

    #backtickLineStart(): MarkdownEntry {

        // If we're not a ```, just treat as regular text
        if (this.#peak()?.type() !== MarkdownTokenType.BackTick || this.#peakInto(2)?.type() !== MarkdownTokenType.BackTick) {
            const starEntries = this.#text();
            this.#assignStandardStyling(starEntries);
            return new BasicMarkdownEntry(starEntries, false, false);
        }
        this.#inc();
        this.#inc();

        let token = this.#next();

        // Eat the first new line character
        if (token?.type() === MarkdownTokenType.NewLine) {
            token = this.#next();
        }

        let start = token?.tokenStart();
        let end = start;

        // Read until we hit another ``` 
        while (token !== null) {

            if (
                token.type() === MarkdownTokenType.BackTick &&
                this.#peak()?.type() === MarkdownTokenType.BackTick &&
                this.#peakInto(2)?.type() === MarkdownTokenType.BackTick
            ) {
                end = token.tokenEnd() - 1;
                break;
            }

            token = this.#next();
        }

        this.#inc(); // puts us on the 2nd
        this.#inc(); // puts us on the 3rd
        this.#inc(); // puts us on the next token

        const codeBlockText = this.#originalText.substring(start as number, end);
        const entryText = new Text(codeBlockText);
        this.#assignStandardStyling([entryText])
        return new CodeBlockEntry(entryText)
    }

    parse(): Array<MarkdownEntry> {
        let token = this.#current();

        const entries = new Array<MarkdownEntry>();

        while (token !== null) {
            switch (token.type()) {
                case MarkdownTokenType.H1:
                    entries.push(this.#h1());
                    break;

                case MarkdownTokenType.H2:
                    entries.push(this.#h2());
                    break;

                case MarkdownTokenType.H3:
                    entries.push(this.#h3());
                    break;

                case MarkdownTokenType.Text:
                    const textEntries = this.#text();
                    this.#assignStandardStyling(textEntries);
                    entries.push(new BasicMarkdownEntry(textEntries, false, false));
                    break;

                case MarkdownTokenType.Star:
                    entries.push(this.#starLineStart());
                    break;

                case MarkdownTokenType.NewLine:
                    this.#inc();
                    break;

                case MarkdownTokenType.BackTick:
                    entries.push(this.#backtickLineStart());
                    break;

                default:
                    this.#inc();
            }

            token = this.#current();
        }

        return entries;
    }
}

================
File: src/markdown/token.ts
================
export enum MarkdownTokenType {
    Text = "Text",
    H1 = "H1",
    H2 = "H2",
    H3 = "H3",
    NewLine = "New Line",
    Star = "Star",
    Space = "Space",
    BackTick = "`"
}

export class MarkdownToken {

    #type: MarkdownTokenType;

    #lexeme: string

    #tokenStart: number

    #tokenEnd: number

    constructor(type: MarkdownTokenType, lexeme: string, tokenStart: number, tokenEnd: number) {
        this.#type = type;
        this.#lexeme = lexeme;
        this.#tokenStart = tokenStart;
        this.#tokenEnd = tokenEnd;
    }

    type(): MarkdownTokenType {
        return this.#type;
    }

    lexeme(): string {
        return this.#lexeme;
    }

    tokenStart(): number {
        return this.#tokenStart;
    }
    tokenEnd(): number {
        return this.#tokenEnd;
    }
}

================
File: src/nodes/factory.ts
================
import { FlowNode } from "../node";
import { Publisher, PublisherConfig } from "./publisher";
import { ContextMenuConfig } from "../contextMenu";
import { Vector2 } from "../types/vector2";
import { nodeFlowGroup as nodeFlowContextMenuGroup, NodeSubsystem } from "./subsystem";

export type NodeCreatedCallback = (publisher: string, nodeType: string, node: FlowNode) => void;

interface NodeFactoryPublishers {
    [name: string]: PublisherConfig
}

export interface NodeFactoryConfig {
    publishers?: NodeFactoryPublishers
    onNodeCreated?: NodeCreatedCallback;
}

export class NodeFactory {
    #registeredPublishers: Map<string, Publisher>;

    #registeredCallbacks: Array<NodeCreatedCallback>;

    constructor(config?: NodeFactoryConfig) {
        this.#registeredPublishers = new Map<string, Publisher>();
        this.#registeredCallbacks = new Array<NodeCreatedCallback>();

        if (config?.onNodeCreated) {
            this.#registeredCallbacks.push(config?.onNodeCreated);
        }

        if (config?.publishers !== undefined) {
            for (let entry in config.publishers) {
                this.addPublisher(entry, new Publisher(config.publishers[entry]));
            }
        }
    }

    public addOnNodeCreatedListener(callback: NodeCreatedCallback): void {
        this.#registeredCallbacks.push(callback);
    }

    public addPublisher(identifier: string, publisher: Publisher): void {
        this.#registeredPublishers.set(identifier, publisher);
    }

    // I'm not even sure if I want this here? You can register on Publishers...
    // So why not just make people register with the publisher.
    // public register(publisher: string, nodeType: string, config: FlowNodeConfiguration): void {
    //     const foundPublisher = this.#registeredPublishers.get(publisher);
    //     if (foundPublisher === undefined) {
    //         console.error("no publisher registered with identifier:" + publisher);
    //         return;
    //     }

    //     foundPublisher.register(nodeType, config);
    // }

    public create(publisher: string, nodeType: string): FlowNode {
        const publisherIdentifier = this.#registeredPublishers.get(publisher)
        if (publisherIdentifier === undefined) {
            throw new Error("no publisher registered with identifier: " + publisher);
        }
        const node = publisherIdentifier.create(nodeType);

        for (let i = 0; i < this.#registeredCallbacks.length; i++) {
            const callback = this.#registeredCallbacks[i];
            callback(publisher, nodeType, node);
        }
        return node;
    }

    public newNodeSubmenus(graph: NodeSubsystem, position: Vector2): Array<ContextMenuConfig> {
        const menus: Array<ContextMenuConfig> = [];
        for (let [_, publisher] of this.#registeredPublishers) {
            menus.push(publisher.contextMenu(graph, position))
        }
        return menus;
    }

    public openMenu(graph: NodeSubsystem, position: Vector2): ContextMenuConfig {
        return {
            name: "New Node",
            group: nodeFlowContextMenuGroup,
            subMenus: this.newNodeSubmenus(graph, position),
        };
    }
}

================
File: src/nodes/publisher.ts
================
import { ContextMenuConfig, ContextMenuItemConfig } from "../contextMenu";
import { FlowNode, FlowNodeConfig } from '../node';
import { Vector2 } from "../types/vector2";
import { NodeSubsystem } from "./subsystem";

interface PublisherNodes {
    [name: string]: FlowNodeConfig
}

export interface PublisherConfig {
    name?: string;
    description?: string;
    version?: string;
    nodes?: PublisherNodes
}

export class Publisher {

    #name: string;

    #description: string;

    #version: string;

    #registeredNodes: Map<string, FlowNodeConfig>

    constructor(config?: PublisherConfig) {
        this.#name = config?.name === undefined ? "Unknown" : config.name;
        this.#description = config?.description === undefined ? "" : config.description;
        this.#version = config?.version === undefined ? "v0.0.0" : config.version;

        this.#registeredNodes = new Map<string, FlowNodeConfig>();

        if (config?.nodes !== undefined) {
            for (const nodeKey in config.nodes) {
                this.register(nodeKey, config.nodes[nodeKey]);
            }
        }
    }

    nodes(): Map<string, FlowNodeConfig> {
        return this.#registeredNodes;
    }

    register(nodeType: string, config: FlowNodeConfig): void {
        this.#registeredNodes.set(nodeType, config);
    }

    #recurseBuildMenu(graph: NodeSubsystem, name: string, subMenu: Map<string, FlowNodeConfig>, position: Vector2): ContextMenuConfig {
        const items: Array<ContextMenuItemConfig> = [];
        const subMenus = new Map<string, Map<string, FlowNodeConfig>>();

        for (let [key, nodeConfig] of subMenu) {
            const elements = key.split("/");
            if (elements.length === 1) {
                items.push({
                    name: key,
                    callback: () => {
                        const node = new FlowNode(nodeConfig);
                        node.setPosition(position);
                        graph.addNode(node);
                    },
                });
            } else {
                if (!subMenus.has(elements[0])) {
                    subMenus.set(elements[0], new Map<string, FlowNodeConfig>());
                }

                const menu = subMenus.get(elements[0]);
                elements.shift();
                menu?.set(elements.join("/"), nodeConfig)
            }
        }

        const menus: Array<ContextMenuConfig> = [];
        for (let [key, nodes] of subMenus) {
            menus.push(this.#recurseBuildMenu(graph, key, nodes, position))
        }

        return {
            name: name,
            items: items,
            subMenus: menus
        }
    }

    contextMenu(graph: NodeSubsystem, position: Vector2): ContextMenuConfig {
        return this.#recurseBuildMenu(graph, this.#name, this.#registeredNodes, position);
    }

    create(nodeType: string): FlowNode {
        const config = this.#registeredNodes.get(nodeType)
        if (config === undefined) {
            throw new Error("no builder registered for node: " + nodeType);
        }
        return new FlowNode(config);
    }
}

================
File: src/nodes/subsystem.ts
================
import { Camera } from "../camera";
import { Connection, ConnectionRenderer, DefaultConnectionRenderer } from "../connection";
import { CombineContextMenus, ContextMenuConfig } from "../contextMenu";
import { RenderResults } from "../graphSubsystem";
import { FlowNode, NodeState } from "../node";
import { Organize } from "../organize";
import { PassSubsystem } from "../pass/subsystem";
import { TimeExecution } from "../performance";
import { Port, PortType } from "../port";
import { BoxStyle } from "../styles/box";
import { CursorStyle } from "../styles/cursor";
import { Theme } from "../theme";
import { Box, BoxIntersection } from "../types/box";
import { List } from "../types/list";
import { Pool, VectorPool } from "../types/pool";
import { AddVector2, CopyVector2, SubVector2, Vector2, Zero } from "../types/vector2";
import { Widget } from "../widgets/widget";
import { NodeCreatedCallback, NodeFactory, NodeFactoryConfig } from "./factory";
import { Publisher } from "./publisher";

export type NodeAddedCallback = (node: FlowNode) => void;
export type NodeRemovedCallback = (node: FlowNode) => void;

export const nodeFlowGroup = "node-flow-graph-node-menu";

export interface ConnectionRendererConfiguration {
    size?: number;
    color?: string;

    mouseOverSize?: number;
    mouseOverColor?: string;

    renderer?: ConnectionRenderer;
}

function BuildConnectionRenderer(config: ConnectionRendererConfiguration | undefined): ConnectionRenderer {
    if (config?.renderer !== undefined) {
        return config.renderer;
    }

    return DefaultConnectionRenderer(
        config?.size === undefined ? 2 : config.size,
        undefined, // config?.color === undefined ? "#00FF00" : config.color,
        config?.mouseOverSize === undefined ? 4 : config.mouseOverSize,
        undefined, // config?.mouseOverColor === undefined ? "#00FF22" : config.mouseOverColor
    );
}

interface PortIntersection {
    Node: FlowNode;
    Port: Port;
    Index: number;
    InputPort: boolean;
}

interface NodeSubsystemConfig {
    idleConnection?: ConnectionRendererConfiguration
    nodes?: NodeFactoryConfig
}

export class NodeSubsystem {

    #postProcessPass: PassSubsystem;

    #nodes: Array<FlowNode>;

    #connections: Array<Connection>;

    #nodeHovering: number;

    #nodesGrabbed: List<number>;

    #connectionSelected: Connection | null;

    #idleConnectionRenderer: ConnectionRenderer

    #portHovering: PortIntersection | null;

    #widgetHovering: Widget | null;

    #widgetCurrentlyClicking: Widget | null;

    #cursor: CursorStyle;

    #nodeFactory: NodeFactory;

    #boxSelect: boolean;

    #boxSelectStart_graphSpace: Vector2;

    #boxSelectEnd_graphSpace: Vector2;

    #boxSelectionNodes: List<number>;

    #boxSelectStyle: BoxStyle;

    // LISTENERS ==============================================================

    #nodeRemovedCallbacks: Array<NodeRemovedCallback>;

    #registeredNodeAddedCallbacks: Array<NodeAddedCallback>;

    // ========================================================================

    constructor(postProcessPass: PassSubsystem, config?: NodeSubsystemConfig) {
        this.#postProcessPass = postProcessPass;
        this.#nodes = [];
        this.#nodeHovering = -1;
        this.#nodesGrabbed = new List<number>();
        this.#connectionSelected = null;
        this.#portHovering = null;
        this.#widgetHovering = null;
        this.#widgetCurrentlyClicking = null;
        this.#connections = new Array<Connection>();
        this.#nodeFactory = new NodeFactory(config?.nodes);
        this.#idleConnectionRenderer = BuildConnectionRenderer(config?.idleConnection);
        this.#registeredNodeAddedCallbacks = new Array<NodeAddedCallback>();
        this.#nodeRemovedCallbacks = new Array<NodeRemovedCallback>();
        this.#cursor = CursorStyle.Default;

        this.#boxSelect = false;
        this.#boxSelectStart_graphSpace = Zero();
        this.#boxSelectEnd_graphSpace = Zero();
        this.#boxSelectionNodes = new List<number>();
        this.#boxSelectStyle = new BoxStyle({
            border: {
                color: Theme.BoxSelect.Color,
                size: Theme.BoxSelect.Size,
            },
            color: "rgba(0,0,0,0)",
            radius: Theme.BoxSelect.Radius
        });
    }

    public addPublisher(identifier: string, publisher: Publisher): void {
        this.#nodeFactory.addPublisher(identifier, publisher);
    }

    public addOnNodeCreatedListener(callback: NodeCreatedCallback): void {
        this.#nodeFactory.addOnNodeCreatedListener(callback);
    }
    
    public nodeFactory(): NodeFactory {
        return this.#nodeFactory;
    }

    public addOnNodeAddedListener(callback: NodeAddedCallback): void {
        if (callback === null || callback === undefined) {
            return;
        }
        this.#registeredNodeAddedCallbacks.push(callback);
    }

    public addOnNodeRemovedListener(callback: NodeRemovedCallback): void {
        if (callback === null || callback === undefined) {
            return;
        }
        this.#nodeRemovedCallbacks.push(callback);
    }

    clickStart(mousePosition: Vector2, camera: Camera, ctrlKey: boolean): boolean {
        this.#boxSelect = false;

        let hoveringSomething = false;
        if (this.#nodeHovering > -1) {
            this.#selectNodeByIndex(this.#nodeHovering, !ctrlKey);

            for (let i = 0; i < this.#nodes.length; i++) {
                if (this.#nodes[i].selected()) {
                    this.#nodesGrabbed.Push(i);
                }
            }

            hoveringSomething = true;
        }

        if (this.#widgetHovering !== null) {
            this.#widgetHovering.ClickStart();
            this.#widgetCurrentlyClicking = this.#widgetHovering;
            hoveringSomething = true;
        }

        if (this.#portHovering === null) {

            if (ctrlKey && !hoveringSomething) {
                camera.screenSpaceToGraphSpace(mousePosition, this.#boxSelectStart_graphSpace)
                CopyVector2(this.#boxSelectEnd_graphSpace, this.#boxSelectStart_graphSpace);
                this.#boxSelect = true;
            }

            return hoveringSomething || ctrlKey;
        }

        if (this.#portHovering.InputPort) {
            for (let i = 0; i < this.#connections.length; i++) {
                if (this.#connections[i].inPort() === this.#portHovering.Port) {
                    this.#connections[i].clearInput();
                    this.#connectionSelected = this.#connections[i];
                    break;
                }
            }
        } else {
            let inNode: FlowNode | null = this.#portHovering.Node
            let inNodeIndex = this.#portHovering.Index
            let outNode: FlowNode | null = this.#portHovering.Node
            let outNodeIndex = this.#portHovering.Index

            if (this.#portHovering.InputPort) {
                outNode = null;
                outNodeIndex = -1;
            } else {
                inNode = null;
                inNodeIndex = -1;
            }

            const connection = new Connection(inNode, inNodeIndex, outNode, outNodeIndex, this.#idleConnectionRenderer);
            this.#connectionSelected = connection;
            this.#connections.push(connection);
        }

        return true;
    }

    mouseDragEvent(delta: Vector2, scale: number): boolean {
        let nodeMoved = false;

        VectorPool.run(() => {
            const scaledDelta = VectorPool.get();
            scaledDelta.x = delta.x / scale;
            scaledDelta.y = delta.y / scale;
            AddVector2(this.#boxSelectEnd_graphSpace, this.#boxSelectEnd_graphSpace, scaledDelta);

            if (this.#interactingWithNode()) {
                for (let i = 0; i < this.#nodesGrabbed.Count(); i++) {
                    const node = this.#nodes[this.#nodesGrabbed.At(i)];
                    if (node.locked()) {
                        continue;
                    }
                    node.translate(scaledDelta);
                    nodeMoved = true;
                }
            }
        });

        if (nodeMoved) {
            return true;
        }
        return this.#interactingWithConnection() || this.#interactingWithWidget() || this.#boxSelect;
    }

    clearNodeInputConnection(node: FlowNode, index: number): void {
        const port = node.inputPort(index);
        for (let i = this.#connections.length - 1; i >= 0; i--) {
            if (this.#connections[i].inPort() === port) {
                this.#removeConnection(this.#connections[i], true);
            }
        }
    }

    clickEnd(): void {

        for (let i = 0; i < this.#nodesGrabbed.Count(); i++) {
            const node = this.#nodes[this.#nodesGrabbed.At(i)];
            node.raiseDragStoppedEvent();
        }
        this.#nodesGrabbed.Clear();

        if (this.#boxSelect) {
            for (let i = 0; i < this.#boxSelectionNodes.Count(); i++) {
                this.#selectNode(this.#nodes[this.#boxSelectionNodes.At(i)], false);
            }

            this.#boxSelectionNodes.Clear();
            this.#boxSelect = false;
        }

        if (this.#widgetCurrentlyClicking !== null) {
            this.#widgetCurrentlyClicking.ClickEnd();
            this.#widgetCurrentlyClicking = null;
        }

        if (this.#connectionSelected === null) {
            return;
        }

        if (this.#portHovering === null) {
            this.#clearCurrentlySelectedConnection();
            return;
        }

        const port = this.#portHovering.Port;
        const conn = this.#connectionSelected;

        // If the port we're hovering is the one we started the connection 
        // with...
        if (port === conn.inPort() || port === conn.outPort()) {
            this.#clearCurrentlySelectedConnection();
            return;
        }

        // If the port we're hoving is input, and also we started the 
        // connection with an input, we can't do anything. We can't connect
        // input to input
        if (this.#portHovering.InputPort && conn.inPort() !== null) {
            this.#clearCurrentlySelectedConnection();
            return;
        }

        // Same with out. Can't connect output to output
        if (!this.#portHovering.InputPort && conn.outPort() !== null) {
            this.#clearCurrentlySelectedConnection();
            return;
        }

        // Different types, can't connect
        if (this.#portHovering.InputPort && this.#portHovering.Port.getDataType() !== conn.outPort()?.getDataType()) {
            this.#clearCurrentlySelectedConnection();
            return;
        }

        // Different types, can't connect
        if (!this.#portHovering.InputPort && this.#portHovering.Port.getDataType() !== conn.inPort()?.getDataType()) {
            this.#clearCurrentlySelectedConnection();
            return;
        }

        // Ight. Let's make the connection.
        if (this.#portHovering.InputPort) {
            let replace = false;
            const inputPort = this.#portHovering.Node.inputPort(this.#portHovering.Index);
            if (this.#portHovering.Port.getPortType() !== PortType.InputArray && inputPort.connections().length > 0) {
                replace = true;
            }

            if (replace) {
                // Remove input port's connection's output
                inputPort.connections()[0].clearOutput();

                // Remove connection from this subsystem
                this.#removeConnection(inputPort.connections()[0], false);
            }
            conn.setInput(this.#portHovering.Node, this.#portHovering.Index, replace);

        } else {
            conn.setOutput(this.#portHovering.Node, this.#portHovering.Index);
        }

        this.#connectionSelected = null;
    }

    connectNodes(nodeOut: FlowNode, outPort: number, nodeIn: FlowNode, inPort: number): Connection | undefined {
        const outType = nodeOut.outputPort(outPort).getDataType();
        const inType = nodeIn.inputPort(inPort).getDataType();
        if (outType !== inType) {
            console.error("can't connect nodes of different types", outType, inType);
            return;
        }

        // Check and make sure the nodes aren't already connected
        const existingInputConnections = nodeIn.inputPort(inPort).connections();
        for (let i = 0; i < existingInputConnections.length; i++) {
            const connection = existingInputConnections[i];


            if (connection.outNode() !== nodeOut) {
                continue;
            }

            if (connection.outPort() !== nodeOut.outputPort(outPort)) {
                continue;
            }

            // This kind of connection already *exists*. Let's not add a duplicate
            return;
        }

        const connection = new Connection(
            nodeIn, inPort,
            nodeOut, outPort,
            this.#idleConnectionRenderer,
        );
        this.#connections.push(connection);
        return connection;
    }

    getNodes(): Array<FlowNode> {
        return this.#nodes;
    }

    /**
     * Returns all nodes who are connected to the inputs of the 
     * node in question
     * 
     * @param nodeIndex index of the node to examine inputs to
     */
    connectedInputsNodeReferencesByIndex(nodeIndex: number): Array<FlowNode> {
        return this.connectedInputsNodeReferences(this.#nodes[nodeIndex]);
    }

    connectedInputsNodeReferences(node: FlowNode): Array<FlowNode> {
        const connections = new Array<FlowNode>();
        for (let i = 0; i < this.#connections.length; i++) {
            const connection = this.#connections[i];
            if (node !== connection.inNode()) {
                continue;
            }

            const outNode = connection.outNode();
            if (outNode === null) {
                continue;
            }

            connections.push(outNode);
        }
        return connections;
    }

    connectedOutputsNodeReferences(nodeIndex: number): Array<FlowNode> {
        const node = this.#nodes[nodeIndex]
        const connections = new Array<FlowNode>();
        for (let i = 0; i < this.#connections.length; i++) {
            const connection = this.#connections[i];
            if (node !== connection.outNode()) {
                continue;
            }

            const inNode = connection.inNode();
            if (inNode === null) {
                continue;
            }

            connections.push(inNode);
        }
        return connections;
    }

    addNode(node: FlowNode): void {
        this.#nodes.push(node);
        for (let i = 0; i < this.#registeredNodeAddedCallbacks.length; i++) {
            const callback = this.#registeredNodeAddedCallbacks[i];
            if (!callback) {
                continue;
            }
            callback(node);
        }
    }

    fileDrop(file: File): boolean {
        if (this.#nodeHovering === -1) {
            return false;
        }
        this.#nodes[this.#nodeHovering].dropFile(file);
        return true;
    }

    #removeNodeConnections(nodeIndex: number): void {
        if (nodeIndex >= this.#nodes.length || nodeIndex < 0) {
            console.error("invalid node connection");
            return;
        }
        for (let i = this.#connections.length - 1; i >= 0; i--) {
            if (this.#connections[i].referencesNode(this.#nodes[nodeIndex])) {
                this.#removeConnectionByIndex(i, true);
            }
        }
    }

    #interactingWithNode(): boolean {
        return this.#nodesGrabbed.Count() > 0;
    }

    #interactingWithConnection(): boolean {
        return this.#connectionSelected !== null;
    }

    #interactingWithWidget(): boolean {
        return this.#widgetCurrentlyClicking !== null;
    }

    #removeNodeByIndex(nodeIndex: number): void {
        this.#removeNodeConnections(nodeIndex);
        const node = this.#nodes[nodeIndex];
        this.#nodes.splice(nodeIndex, 1);
        for (let i = 0; i < this.#nodeRemovedCallbacks.length; i++) {
            this.#nodeRemovedCallbacks[i](node);
        }
    }

    #removeConnectionByIndex(index: number, clearPorts: boolean): void {
        if (clearPorts) {
            this.#connections[index].clearPorts();
        }
        this.#connections.splice(index, 1);
    }

    #removeConnection(connection: Connection, clearPorts: boolean): void {
        const index = this.#connections.indexOf(connection);
        if (index > -1) {
            this.#removeConnectionByIndex(index, clearPorts);
        } else {
            console.error("no connection found to remove");
        }
    }

    organize(ctx: CanvasRenderingContext2D): void {
        Organize(ctx, this);
    }

    #nodesSelected(): Array<number> {
        const selected = new Array<number>();
        for (let i = 0; i < this.#nodes.length; i++) {
            if (this.#nodes[i].selected()) {
                selected.push(i);
            }
        }
        return selected;
    }

    #organizeSelected(ctx: CanvasRenderingContext2D): void {
        Organize(ctx, this, this.#nodesSelected());
    }

    openContextMenu(ctx: CanvasRenderingContext2D, position: Vector2): ContextMenuConfig | null {

        const organizeNodesSubMenu: ContextMenuConfig = {
            name: "Organize",
            group: nodeFlowGroup,
            items: [
                {
                    name: "All Nodes",
                    group: nodeFlowGroup,
                    callback: () => {
                        this.organize(ctx);
                    }
                }
            ]
        }

        let config: ContextMenuConfig = {
            items: [],
            subMenus: [
                organizeNodesSubMenu,
                this.#nodeFactory.openMenu(this, position)
            ]
        }

        if (this.#nodesSelected().length > 0) {
            organizeNodesSubMenu.items?.push({
                name: "Selected Nodes",
                group: nodeFlowGroup,
                callback: () => {
                    this.#organizeSelected(ctx)
                }
            })
        }

        if (this.#nodeHovering > -1) {
            const nodeToReview = this.#nodeHovering;
            const nodeToReviewNode = this.#nodes[nodeToReview];

            config.subMenus?.push({
                group: nodeFlowGroup,
                name: "Select",
                items: [
                    {
                        name: "Direct Connected Nodes",
                        group: nodeFlowGroup,
                        callback: () => {
                            this.#selectConnectedNodes(nodeToReview);
                        }
                    },
                    {
                        name: "Input Nodes + Descendents",
                        group: nodeFlowGroup,
                        callback: () => {
                            this.#selectInputNodesAndDescendents(nodeToReviewNode);
                        }
                    },
                ]
            })

            config.subMenus?.push({
                group: nodeFlowGroup,
                name: "Delete",
                items: [
                    {
                        name: "Node",
                        group: nodeFlowGroup,
                        callback: () => {
                            this.#removeNodeByIndex(nodeToReview);
                        }
                    },
                    {
                        name: "Connections",
                        group: nodeFlowGroup,
                        callback: () => {
                            this.#removeNodeConnections(nodeToReview);
                        }
                    }
                ]
            })
            config = CombineContextMenus(config, nodeToReviewNode.contextMenu());
        }
        return config;
    }

    #selectInputNodesAndDescendents(node: FlowNode): void {
        if (node === undefined) {
            return;
        }
        this.#selectNode(node, false);

        const inputs = this.connectedInputsNodeReferences(node);
        for (let i = 0; i < inputs.length; i++) {
            this.#selectInputNodesAndDescendents(inputs[i]);
        }
    }

    #selectConnectedNodes(nodeIndex: number): void {
        const node = this.#nodes[nodeIndex];
        if (node === undefined) {
            return;
        }
        this.#selectNode(node, false);

        const outputs = this.connectedOutputsNodeReferences(nodeIndex);
        for (let i = 0; i < outputs.length; i++) {
            this.#selectNode(outputs[i], false);
        }

        const inputs = this.connectedInputsNodeReferencesByIndex(nodeIndex);
        for (let i = 0; i < inputs.length; i++) {
            this.#selectNode(inputs[i], false);
        }
    }

    #selectNodeByIndex(nodeIndex: number, unselectOthers: boolean): void {
        this.#selectNode(this.#nodes[nodeIndex], unselectOthers);
    }

    #selectNode(node: FlowNode, unselectOthers: boolean): void {
        node.select();

        if (!unselectOthers) {
            return;
        }

        for (let i = 0; i < this.#nodes.length; i++) {
            if (node === this.#nodes[i]) {
                continue
            }
            this.#nodes[i].unselect();
        }
    }

    #clearCurrentlySelectedConnection(): void {
        if (this.#connectionSelected === null) {
            return;
        }
        this.#removeConnection(this.#connectionSelected, true);
        this.#connectionSelected = null;
    }

    #renderConnections(ctx: CanvasRenderingContext2D, camera: Camera, mousePosition: Vector2 | undefined): void {
        for (let i = 0; i < this.#connections.length; i++) {
            let portMousedOver = false;
            if (mousePosition !== undefined) {
                portMousedOver = this.#connections[i].mouseOverPort(mousePosition) !== null;
            }
            this.#connections[i].render(ctx, camera.zoom, portMousedOver, mousePosition);
        }
    }

    #renderNodes(ctx: CanvasRenderingContext2D, camera: Camera, mousePosition: Vector2 | undefined) {
        this.#portHovering = null;
        this.#widgetHovering = null;
        this.#nodeHovering = -1;
        this.#boxSelectionNodes.Clear();

        const selectedBox_Screenspace = this.#boxSelectionScreenspaceBox(camera);

        for (let i = 0; i < this.#nodes.length; i++) {
            let state = NodeState.Idle;

            if (mousePosition !== undefined && !this.#boxSelect) {
                const intersection = this.#nodes[i].inBounds(ctx, camera, mousePosition);

                if (intersection.Node !== undefined && intersection.PortIndex === undefined && intersection.Widget === undefined) {
                    state = NodeState.MouseOver;
                    this.#nodeHovering = i;
                    this.#cursor = CursorStyle.Grab;
                }

                if (intersection.Widget !== undefined) {
                    // console.log(i, this.#nodes[i].title(), "widget")
                    this.#widgetHovering = intersection.Widget
                    this.#cursor = CursorStyle.Pointer;
                }

                if (intersection.Port !== undefined && intersection.Node !== undefined && intersection.PortIndex !== undefined && intersection.PortIsInput !== undefined) {
                    this.#portHovering = {
                        Index: intersection.PortIndex,
                        Node: intersection.Node,
                        Port: intersection.Port,
                        InputPort: intersection.PortIsInput
                    };
                }
            } else if (this.#boxSelect) {
                const nodeBounds = this.#nodes[i].calculateBounds(ctx, camera);

                if (BoxIntersection(selectedBox_Screenspace, nodeBounds)) {
                    state = NodeState.MouseOver;
                    this.#boxSelectionNodes.Push(i);
                }
            }

            // if (i === this.#nodeSelected) {
            //     state = NodeState.Selected;
            // }

            if (this.#nodes[i].selected() && this.#nodesGrabbed.Count() > 0) {
                state = NodeState.Grabbed;
                this.#cursor = CursorStyle.Grabbing;
            }

            this.#nodes[i].render(ctx, camera, state, mousePosition, this.#postProcessPass);
        }
    }

    #boxSelectionScreenspaceBox(camera: Camera): Box {
        const box = { Position: Zero(), Size: Zero() }

        camera.graphSpaceToScreenSpace(this.#boxSelectStart_graphSpace, box.Position);
        camera.graphSpaceToScreenSpace(this.#boxSelectEnd_graphSpace, box.Size);

        SubVector2(box.Size, box.Size, box.Position);

        return box;
    }

    render(ctx: CanvasRenderingContext2D, camera: Camera, mousePosition: Vector2 | undefined): RenderResults | undefined {
        this.#cursor = CursorStyle.Default;
        TimeExecution("Render_Connections", () => {
            this.#renderConnections(ctx, camera, mousePosition);
        })
        TimeExecution("Render_Nodes", () => {
            this.#renderNodes(ctx, camera, mousePosition);
        })

        if (this.#boxSelect) {
            const box = this.#boxSelectionScreenspaceBox(camera);
            ctx.setLineDash([Theme.BoxSelect.LineDashLength]);
            this.#boxSelectStyle.Draw(ctx, box, 1);
            ctx.setLineDash([]);
        }

        return { cursorStyle: this.#cursor }
    }

}

================
File: src/notes/note.ts
================
import { BuildMarkdown } from "../markdown/markdown";
import { MarkdownEntry } from "../markdown/entry";
import { Popup } from "../popup";
import { BoxStyle } from "../styles/box";
import { TextAlign } from "../styles/canvasTextAlign";
import { TextBaseline } from "../styles/canvasTextBaseline";
import { TextStyleConfig } from "../styles/text";
import { Theme } from "../theme";
import { Box } from "../types/box";
import { CopyVector2, Vector2, Zero } from "../types/vector2";
import { Camera } from "../camera";
import { Metadata } from "../metadata";

export type NoteContentChangeCallback = (node: FlowNote, newContents: string) => void
export type NoteWidthChangeCallback = (node: FlowNote, newWidth: number) => void

export interface FlowNoteConfig {
    text?: string;
    style?: TextStyleConfig;
    metadata?: Metadata;
    position?: Vector2;
    width?: number;
    locked?: boolean;
    onWidthChange?: NoteWidthChangeCallback;
    onContentChange?: NoteContentChangeCallback;
}

export enum DragHandle {
    None,
    Left,
    Right
};

const BOUNDS_SPACING = 20;
const BOX_SIZE = 10;

export class FlowNote {

    #originalText: string;

    #document: Array<MarkdownEntry>;

    #width: number;

    #edittingStyle: BoxStyle;

    // Runtime ================================================================

    #data: Metadata;

    #position: Vector2;

    #handleSelected: DragHandle;

    #edittingLayout: boolean;

    #lastRenderedBox: Box;

    #hovering: boolean;

    // Callbacks ==============================================================

    #widthChangeCallbacks: Array<NoteWidthChangeCallback>;

    #contentChangeCallbacks: Array<NoteContentChangeCallback>;

    // ========================================================================

    constructor(config?: FlowNoteConfig) {
        this.#widthChangeCallbacks = new Array<NoteWidthChangeCallback>();
        this.#contentChangeCallbacks = new Array<NoteContentChangeCallback>();
        this.#data = config?.metadata === undefined ? {} : config?.metadata;
        this.#document = [];
        this.#originalText = "";
        this.#hovering = false;
        this.#edittingLayout = config?.locked === undefined ? true : !config?.locked;
        this.#width = config?.width === undefined ? 500 : config.width;
        this.#position = config?.position === undefined ? { x: 0, y: 0 } : config.position;
        this.setText(config?.text === undefined ? "" : config?.text);
        this.#lastRenderedBox = { Position: { x: 0, y: 0 }, Size: { x: 0, y: 0 } };
        this.#handleSelected = DragHandle.None;

        this.#edittingStyle = new BoxStyle({
            border: {
                color: "white",
                size: 1
            },
        })

        if (config?.onWidthChange) {
            this.#widthChangeCallbacks.push(config.onWidthChange);
        }

        if (config?.onContentChange) {
            this.#contentChangeCallbacks.push(config.onContentChange);
        }
    }

    setText(text: string): void {
        this.#originalText = text;
        this.#document = BuildMarkdown(this.#originalText);
        for (let i = 0; i < this.#contentChangeCallbacks.length; i++) {
            this.#contentChangeCallbacks[i](this, text);
        }
    }

    public setMetadataProperty(name: string, value: any): void {
        this.#data[name] = value;
    }

    public getMetadataProperty(name: string): any {
        return this.#data[name];
    }

    text(): string {
        return this.#originalText;
    }

    width(): number {
        return this.#width;
    }

    position(): Vector2 {
        return this.#position;
    }

    translate(delta: Vector2): void {
        this.#position.x += delta.x;
        this.#position.y += delta.y;
    }

    setPosition(position: Vector2): void {
        CopyVector2(this.#position, position);
    }

    handleSelected(): DragHandle {
        return this.#handleSelected;
    }

    selectHandle(handle: DragHandle): void {
        this.#handleSelected = handle;
    }

    #tempPosition: Vector2 = Zero();

    public setWidth(newWidth: number): void {
        if (newWidth === undefined) {
            console.error("Attempted to set note's width to undefined");
        }
        this.#width = newWidth;
        for (let i = 0; i < this.#widthChangeCallbacks.length; i++) {
            this.#widthChangeCallbacks[i](this, newWidth);
        }
    }

    public addWidthChangeListener(callback: NoteWidthChangeCallback): void {
        if (callback === null || callback === undefined) {
            return;
        }
        this.#widthChangeCallbacks.push(callback);
    }

    public addContentChangeListener(callback: NoteContentChangeCallback): void {
        if (callback === null || callback === undefined) {
            return;
        }
        this.#contentChangeCallbacks.push(callback);
    }

    render(ctx: CanvasRenderingContext2D, camera: Camera, mousePosition: Vector2 | undefined): void {
        if (this.#edittingLayout && (this.#hovering || this.#handleSelected !== DragHandle.None)) {

            if (mousePosition) {
                if (this.#handleSelected === DragHandle.Right) {

                    const leftPosition = (this.#position.x * camera.zoom) + camera.position.x;
                    this.setWidth(Math.max((mousePosition.x - leftPosition) / camera.zoom, 1));

                } else if (this.#handleSelected === DragHandle.Left) {

                    const scaledWidth = this.#width * camera.zoom;
                    const rightPosition = (this.#position.x * camera.zoom) + camera.position.x + scaledWidth;
                    this.setWidth(Math.max((rightPosition - mousePosition.x) / camera.zoom, 1));
                    this.#position.x = rightPosition - (this.#width * camera.zoom) - camera.position.x;
                    this.#position.x /= camera.zoom;
                }
            }

            this.#edittingStyle.Outline(ctx, this.leftResizeHandleBox(), camera.zoom, 2);
            this.#edittingStyle.Outline(ctx, this.rightResizeHandleBox(), camera.zoom, 2);

            ctx.beginPath();
            const left = this.#lastRenderedBox.Position.x;
            const right = this.#lastRenderedBox.Position.x + this.#lastRenderedBox.Size.x;
            const bottom = this.#lastRenderedBox.Position.y;
            const top = this.#lastRenderedBox.Position.y + this.#lastRenderedBox.Size.y;
            ctx.moveTo(left, bottom + (this.#lastRenderedBox.Size.y / 2) - (BOX_SIZE));
            ctx.lineTo(left, bottom);
            ctx.lineTo(right, bottom);
            ctx.lineTo(right, bottom + (this.#lastRenderedBox.Size.y / 2) - (BOX_SIZE));

            ctx.moveTo(left, top - (this.#lastRenderedBox.Size.y / 2) + (BOX_SIZE));
            ctx.lineTo(left, top);
            ctx.lineTo(right, top);
            ctx.lineTo(right, top - (this.#lastRenderedBox.Size.y / 2) + (BOX_SIZE));
            ctx.stroke();
            // this.#edittingStyle.Outline(ctx, bigBox, camera.zoom, 2);
        }

        camera.graphSpaceToScreenSpace(this.#position, this.#tempPosition);
        CopyVector2(this.#lastRenderedBox.Position, this.#tempPosition)

        const startY = this.#tempPosition.y;
        const lineSpacing = Theme.Note.EntrySpacing * camera.zoom;

        ctx.textAlign = TextAlign.Left;
        ctx.textBaseline = TextBaseline.Alphabetic;
        for (let i = 0; i < this.#document.length; i++) {
            const text = this.#document[i];
            this.#tempPosition.y += text.render(ctx, this.#tempPosition, camera.zoom, this.#width) + lineSpacing;
        }

        this.#lastRenderedBox.Position.x -= BOUNDS_SPACING
        this.#lastRenderedBox.Position.y -= BOUNDS_SPACING
        this.#lastRenderedBox.Size.x = camera.zoom * this.#width + (BOUNDS_SPACING * 2);
        this.#lastRenderedBox.Size.y = this.#tempPosition.y - startY + (BOUNDS_SPACING * 2);
    }

    leftResizeHandleBox(): Box {
        return {
            Position: {
                x: this.#lastRenderedBox.Position.x - (BOX_SIZE / 2),
                y: this.#lastRenderedBox.Position.y + (this.#lastRenderedBox.Size.y / 2) - (BOX_SIZE / 2),
            },
            Size: { x: BOX_SIZE, y: BOX_SIZE, }
        };
    }

    rightResizeHandleBox(): Box {
        return {
            Position: {
                x: this.#lastRenderedBox.Position.x - (BOX_SIZE / 2) + this.#lastRenderedBox.Size.x,
                y: this.#lastRenderedBox.Position.y + (this.#lastRenderedBox.Size.y / 2) - (BOX_SIZE / 2),
            },
            Size: { x: BOX_SIZE, y: BOX_SIZE, }
        };
    }

    edittingLayout(): boolean {
        return this.#edittingLayout;
    }

    setHovering(hovering: boolean): void {
        this.#hovering = hovering;
    }

    editContent(): void {
        let input: HTMLTextAreaElement | null = null;
        let saveText = "Save";

        const popup = new Popup({
            title: "Edit Note",
            options: [saveText, "Cancel"],
            content: () => {
                const container = document.createElement('div');
                input = document.createElement('textarea')
                input.rows = 8;
                input.cols = 50;
                input.value = this.#originalText;
                container.append(input);
                return container;
            },
            onClose: (button: string | null): void => {
                if (button !== saveText || input === null) {
                    return;
                }
                this.setText(input.value);
            },
        });

        popup.Show();
    }

    lock(): void {
        this.#edittingLayout = false;
    }

    unlock(): void {
        this.#edittingLayout = true;
    }

    bounds(): Box {
        return this.#lastRenderedBox;
    }
}

================
File: src/notes/subsystem.ts
================
import { Camera } from "../camera";
import { ContextMenuConfig } from "../contextMenu";
import { RenderResults } from "../graphSubsystem";
import { InBox } from "../types/box";
import { Vector2 } from "../types/vector2";
import { DragHandle, FlowNote, FlowNoteConfig } from './note';


export type NoteAddedCallback = (addedNote: FlowNote) => void
export type NoteRemovedCallback = (noteRemoved: FlowNote) => void

export type NoteDragStartCallback = (nodeDragged: FlowNote) => void
export type NoteDragStopCallback = (nodeDragged: FlowNote) => void


export interface NoteSubsystemConfig {
    onNoteAdded?: NoteAddedCallback;
    onNoteRemoved?: NoteRemovedCallback;
    onNoteDragStop?: NoteDragStopCallback
    onNoteDragStart?: NoteDragStartCallback
    notes?: Array<FlowNoteConfig>
}

export class NoteSubsystem {

    #notes: Array<FlowNote>;

    #noteHovering: FlowNote | null;

    #noteSelected: FlowNote | null;

    #hoveringHandle: DragHandle;

    #onNoteAddedCallbacks: Array<NoteAddedCallback>;

    #onNoteRemovedCallbacks: Array<NoteRemovedCallback>;

    #onNoteDragStartCallbacks: Array<NoteDragStartCallback>;

    #onNoteDragStopCallbacks: Array<NoteDragStopCallback>;

    constructor(config?: NoteSubsystemConfig) {
        this.#hoveringHandle = DragHandle.None;
        this.#notes = [];
        this.#noteHovering = null;
        this.#noteSelected = null;

        // Callbacks
        this.#onNoteAddedCallbacks = new Array<NoteAddedCallback>();
        this.#onNoteRemovedCallbacks = new Array<NoteRemovedCallback>();
        this.#onNoteDragStartCallbacks = new Array<NoteDragStartCallback>();
        this.#onNoteDragStopCallbacks = new Array<NoteDragStopCallback>();

        if (config?.notes !== undefined) {
            for (let i = 0; i < config?.notes.length; i++) {
                this.addNote(new FlowNote(config?.notes[i]));
            }
        }

        // Add callback *after* we added all the initial notes
        if (config?.onNoteAdded !== undefined) {
            this.#onNoteAddedCallbacks.push(config?.onNoteAdded);
        }

        if (config?.onNoteDragStop !== undefined) {
            this.#onNoteDragStopCallbacks.push(config?.onNoteDragStop);
        }

        if (config?.onNoteDragStart !== undefined) {
            this.#onNoteDragStartCallbacks.push(config?.onNoteDragStart);
        }

        if (config?.onNoteRemoved !== undefined) {
            this.#onNoteRemovedCallbacks.push(config?.onNoteRemoved);
        }
    }

    addNote(note: FlowNote): void {
        if (note === null || note === undefined) {
            return;
        }

        this.#notes.push(note);
        for (let i = 0; i < this.#onNoteAddedCallbacks.length; i++) {
            this.#onNoteAddedCallbacks[i](note);
        }
    }

    public addNoteAddedListener(callback: NoteAddedCallback): void {
        if (callback === null || callback === undefined) {
            return;
        }
        this.#onNoteAddedCallbacks.push(callback);
    }

    public addNoteRemovedListener(callback: NoteRemovedCallback): void {
        if (callback === null || callback === undefined) {
            return;
        }
        this.#onNoteRemovedCallbacks.push(callback);
    }

    public addNoteDragStartListener(callback: NoteDragStartCallback): void {
        if (callback === null || callback === undefined) {
            return;
        }
        this.#onNoteDragStartCallbacks.push(callback);
    }

    public addNoteDragStopListener(callback: NoteDragStopCallback): void {
        if (callback === null || callback === undefined) {
            return;
        }
        this.#onNoteDragStopCallbacks.push(callback);
    }

    openContextMenu(ctx: CanvasRenderingContext2D, position: Vector2): ContextMenuConfig | null {
        const group = "node-flow-graph-note-menu";

        const result: ContextMenuConfig = {
            items: [
                {
                    name: "New Note",
                    group: group,
                    callback: () => {
                        this.addNote(new FlowNote({
                            text: "#Note\n\nRight-click this note and select \"edit note\" to put what you want here.",
                            width: 300,
                            position: position
                        }))
                    }
                }
            ],
            subMenus: [],
        }

        if (this.#noteHovering !== null) {
            const noteToReview = this.#noteHovering;
            result.items?.push(
                {
                    name: "Delete Note",
                    group: group,
                    callback: () => {
                        this.removeNote(noteToReview);
                    }
                },
                {
                    name: "Edit Note",
                    group: group,
                    callback: noteToReview.editContent.bind(noteToReview),
                },
            );

            if (!noteToReview.edittingLayout()) {
                result.items?.push({
                    name: "Unlock Note",
                    group: group,
                    callback: noteToReview.unlock.bind(noteToReview),
                })
            } else {
                result.items?.push({
                    name: "Lock Note",
                    group: group,
                    callback: noteToReview.lock.bind(noteToReview),
                })
            }
        }

        return result;
    }

    clickStart(mousePosition: Vector2, camera: Camera, ctrlKey: boolean): boolean {
        if (this.#noteHovering !== null && this.#noteHovering.edittingLayout()) {
            this.#noteSelected = this.#noteHovering;
            this.#noteSelected.selectHandle(this.#hoveringHandle);

            for (let i = 0; i < this.#onNoteDragStartCallbacks.length; i++) {
                this.#onNoteDragStartCallbacks[i](this.#noteSelected);
            }
            return true;
        }
        return false;
    }

    clickEnd(): void {
        if (this.#noteSelected !== null) {
            this.#noteSelected.selectHandle(DragHandle.None);
            for (let i = 0; i < this.#onNoteDragStopCallbacks.length; i++) {
                this.#onNoteDragStopCallbacks[i](this.#noteSelected);
            }
        }
        this.#noteSelected = null;
    }

    mouseDragEvent(delta: Vector2, scale: number): boolean {
        if (this.#noteSelected === null) {
            return false;
        }

        // Return early so we don't translate since we're moving a drag handle
        if (this.#noteSelected.handleSelected()) {
            return true;
        }

        this.#noteSelected.translate({
            x: delta.x * (1 / scale),
            y: delta.y * (1 / scale)
        });
        return true;
    }

    fileDrop(file: File): boolean {
        return false;
    }

    removeNote(note: FlowNote): void {
        const index = this.#notes.indexOf(note);
        if (index > -1) {
            const noteRemoved = this.#notes[index];
            this.#notes.splice(index, 1);

            for (let i = 0; i < this.#onNoteRemovedCallbacks.length; i++) {
                this.#onNoteRemovedCallbacks[i](noteRemoved)
            }
        } else {
            console.error("no note found to remove");
        }
    }

    render(ctx: CanvasRenderingContext2D, camera: Camera, mousePosition: Vector2 | undefined): RenderResults | undefined {
        this.#noteHovering = null;
        this.#hoveringHandle = DragHandle.None;

        // Set hovering to false on everything
        if (mousePosition) {
            for (let i = 0; i < this.#notes.length; i++) {
                this.#notes[i].setHovering(false);
                if (InBox(this.#notes[i].bounds(), mousePosition)) {
                    this.#noteHovering = this.#notes[i];
                }
            }
        }

        // The note on top of everything is the one that get's to be in a 
        // hover state
        if (this.#noteHovering != null) {
            this.#noteHovering.setHovering(true);
            if (mousePosition) {
                if (InBox(this.#noteHovering.leftResizeHandleBox(), mousePosition)) {
                    this.#hoveringHandle = DragHandle.Left;
                } else if (InBox(this.#noteHovering.rightResizeHandleBox(), mousePosition)) {
                    this.#hoveringHandle = DragHandle.Right;
                }
            }
        }

        for (let i = 0; i < this.#notes.length; i++) {
            this.#notes[i].render(ctx, camera, mousePosition);
        }
        return;
    }
}

================
File: src/pass/subsystem.ts
================
import { Camera } from "../camera";
import { ContextMenuConfig } from "../contextMenu";
import { RenderResults } from "../graphSubsystem";
import { List } from "../types/list";
import { Vector2 } from "../types/vector2";

type RenderLambda = () => void


/**
 * Generic subsystem meant for other sybsystems to pass whatever to to render 
 * at a certain time.
 * 
 * Initial inspriation is for a subsytem to submit something to render on top 
 * of all other subsystems.
 */
export class PassSubsystem {

    #queue: List<RenderLambda>

    constructor() {
        this.#queue = new List<RenderLambda>();
    }

    queue(lambda: RenderLambda): void {
        if(!lambda) {
            return;
        }
        this.#queue.Push(lambda);
    }

    render(ctx: CanvasRenderingContext2D, camera: Camera, mousePosition: Vector2 | undefined): RenderResults | undefined {
        for (let i = 0; i < this.#queue.Count(); i++) {
            this.#queue.At(i)();
        }
        this.#queue.Clear();
        return;
    }

    openContextMenu(ctx: CanvasRenderingContext2D, position: Vector2): ContextMenuConfig | null {
        // Left intentionally blank
        return null;
    }

    clickStart(mousePosition: Vector2, camera: Camera, ctrlKey: boolean): boolean {
        // Left intentionally blank
        return false;
    }

    mouseDragEvent(delta: Vector2, scale: number): boolean {
        // Left intentionally blank
        return false;
    }

    fileDrop(file: File): boolean {
        // Left intentionally blank
        return false;
    }

    clickEnd(): void {
        // Left intentionally blank
    }

}

================
File: src/popups/form.ts
================
import { Popup } from "../popup";

interface FormValue {
    name: string;

    // https://html.spec.whatwg.org/multipage/input.html#dom-input-type
    type: string;

    startingValue: any;
}

interface Config {
    title: string;
    form: Array<FormValue>;
    onUpdate: (newValue: Array<any>) => void;
    onCancel?: () => void;
}

export function FormPopup(config: Config): Popup {
    let input = new Array<HTMLInputElement | null>();

    const setOption = "Set";
    const cancelOption = "Cancel";

    return new Popup({
        title: config.title,
        options: [setOption, cancelOption],
        content: () => {
            const container = document.createElement('div');
            container.style.flexDirection = "column";
            container.style.display = "flex";

            for (let i = 0; i < config.form.length; i++) {
                const title = document.createElement("h4");
                title.innerText = config.form[i].name;
                container.append(title);

                const ele = document.createElement('input');
                ele.value = config.form[i].startingValue;
                ele.type = config.form[i].type;
                container.append(ele);
                input.push(ele);
                container.append(document.createElement("br"));
            }

            return container;
        },
        onClose: (button: string | null): void => {
            if (button !== setOption || input === null) {
                if (config.onCancel) {
                    config.onCancel();
                }
                return;
            }

            const values = new Array<any>();
            for (let i = 0; i < config.form.length; i++) {
                values[i] = input[i]?.value;
            }
            config.onUpdate(values);
        },
    });
}

================
File: src/popups/string.ts
================
import { Popup } from "../popup";

interface Config {
    title: string;
    startingValue: string;
    onUpdate: (newValue: string) => void;
    onCancel?: () => void;
}

export function SetStringPopup(config: Config): Popup {
    let input: HTMLInputElement | null = null;

    return new Popup({
        title: config.title,
        options: ["Set", "Cancel"],
        content: () => {
            const container = document.createElement('div');
            input = document.createElement('input')
            input.value = config.startingValue;
            container.append(input);
            return container;
        },
        onClose: (button: string | null): void => {
            if (button !== "Set" || input === null) {
                if(config.onCancel) {
                    config.onCancel();
                }
                return;
            }
            config.onUpdate(input.value);
        },
    });
}

================
File: src/styles/box.ts
================
import { Box } from "../types/box";
import { StrokeStyle, StrokeStyleConfig, StrokeStyleWithFallback } from "./stroke";

export interface BoxStyleConfig {
    border?: StrokeStyleConfig;
    color?: string;
    radius?: number;
}

export function BoxStyleWithFallback(input?: BoxStyleConfig, fallback?: BoxStyleConfig): BoxStyleConfig {
    return {
        radius: input?.radius === undefined ? fallback?.radius : input?.radius,
        color: input?.color === undefined ? fallback?.color : input?.color,
        border: StrokeStyleWithFallback(input?.border, fallback?.border)
    };
}

export class BoxStyle {
    #border: StrokeStyle | null;

    #color: string;

    #radius: number;

    constructor(config?: BoxStyleConfig) {
        this.#color = config?.color === undefined ? "#CCCCCC" : config.color;
        this.#border = config?.border === undefined ? null : new StrokeStyle(config.border);
        this.#radius = config?.radius === undefined ? 2 : config.radius;
    }

    #box(ctx: CanvasRenderingContext2D, box: Box, scale: number, radius: any): void {
        ctx.fillStyle = this.#color
        this.#border?.setupStyle(ctx, scale);
        ctx.beginPath();
        ctx.roundRect(
            box.Position.x,
            box.Position.y,
            box.Size.x,
            box.Size.y,
            radius
        );
        ctx.fill();
    }

    #draw(ctx: CanvasRenderingContext2D, box: Box, scale: number, radius: any): void {
        this.#box(ctx, box, scale, radius);
        ctx.stroke();
    }

    Outline(ctx: CanvasRenderingContext2D, box: Box, scale: number, radius: any): void {
        this.#border?.setupStyle(ctx, scale);
        ctx.beginPath();
        ctx.roundRect(
            box.Position.x,
            box.Position.y,
            box.Size.x,
            box.Size.y,
            radius
        );
        ctx.stroke();
    }

    Draw(ctx: CanvasRenderingContext2D, box: Box, scale: number): void {
        this.#draw(ctx, box, scale, this.#radius * scale)
    }

    DrawRoundedTopOnly(ctx: CanvasRenderingContext2D, box: Box, scale: number): void {
        this.#draw(ctx, box, scale, [this.#radius * scale * 2, this.#radius * scale * 2, 0, 0])
    }

    DrawUnderline(ctx: CanvasRenderingContext2D, box: Box, scale: number): void {
        this.#box(ctx, box, scale, [this.#radius * scale * 2, this.#radius * scale * 2, 0, 0]);
        ctx.beginPath();
        ctx.moveTo(box.Position.x, box.Position.y + box.Size.y)
        ctx.lineTo(box.Position.x + box.Size.x, box.Position.y + box.Size.y);
        ctx.stroke();
    }

    borderSize(): number {
        if (this.#border === null) {
            return 0;
        }
        return this.#border.size();
    }

    radius(): number {
        return this.#radius;
    }

    setColor(color: string): void {
        this.#color = color;
    }

    setBorderColor(color: string): void {
        if (this.#border === null) {
            this.#border = new StrokeStyle({
                color: color
            })
        } else {
            this.#border.setColor(color);
        }
    }

}

================
File: src/styles/canvasTextAlign.ts
================
export const enum TextAlign {
    Center = "center",
    End = "end",
    Left = "left",
    Right = "right",
    Start = "start"
}

================
File: src/styles/canvasTextBaseline.ts
================
export enum TextBaseline {
    Alphabetic = "alphabetic",
    Bottom = "bottom",
    Hanging = "hanging",
    Ideographic = "ideographic",
    Middle = "middle",
    Top = "top",
}

================
File: src/styles/cursor.ts
================
// https://developer.mozilla.org/en-US/docs/Web/CSS/cursor
export enum CursorStyle {
    Default = 'default',
    Pointer = 'pointer',
    Grab = 'grab',
    Grabbing = 'grabbing',
    Wait = 'wait',
    Help = 'help',
    Crosshair = 'crosshair',
    Cell = 'cell',
    Text = 'text',
    Move = 'move',
    NotAllowed = 'not-allowed',
    ZoomIn = 'zoom-in',
    ZoomOut = 'zoom-out',
    None = 'none',
    ContextMenu = 'context-menu',
}

================
File: src/styles/stroke.ts
================
export interface StrokeStyleConfig {
    size?: number;
    color?: string;
}

export function StrokeStyleWithFallback(input?: StrokeStyleConfig, fallback?: StrokeStyleConfig): StrokeStyleConfig {
    return {
        color: input?.color === undefined ? fallback?.color : input?.color,
        size: input?.size === undefined ? fallback?.size : input?.size,
    };
}

export class StrokeStyle {
    #size: number;

    #color: string;

    constructor(config?: StrokeStyleConfig) {
        this.#size = config?.size === undefined ? 0.5 : config.size;
        this.#color = config?.color === undefined ? "black" : config.color;
    }

    setupStyle(ctx: CanvasRenderingContext2D, scale: number): void {
        ctx.strokeStyle = this.#color;
        ctx.lineWidth = scale * this.#size;
    }

    setColor(newColor: string): void {
        this.#color = newColor;
    }

    setSize(newSize: number): void {
        this.#size = newSize;
    }

    size(): number {
        return this.#size;
    }
}

================
File: src/styles/text.ts
================
import { Theme } from "../theme";
import { Vector2 } from "../types/vector2";

export enum FontWeight {
    Normal = "",
    Bold = "bold"
}

export enum FontStyle {
    Normal = "",
    Italic = "italic"
}

export interface TextStyleConfig {
    size?: number;
    color?: string;
    font?: string;
    weight?: FontWeight;
    style?: FontStyle;
}

const DefaultSize: number = 16;
const DefaultColor: string = "black";

export function TextStyleFallback(input?: TextStyleConfig, fallback?: TextStyleConfig): TextStyleConfig {
    return {
        color: input?.color === undefined ? fallback?.color : input?.color,
        size: input?.size === undefined ? fallback?.size : input?.size,
        font: input?.font === undefined ? fallback?.font : input?.font,
        style: input?.style === undefined ? fallback?.style : input?.style,
        weight: input?.weight === undefined ? fallback?.weight : input?.weight,
    };
}

export class TextStyle {

    #size: number;

    #color: string;

    #font: string;

    #weight: FontWeight;

    #fontStyle: FontStyle;

    constructor(config: TextStyleConfig | undefined) {
        this.#size = config?.size === undefined ? DefaultSize : config.size;
        this.#color = config?.color === undefined ? DefaultColor : config.color;
        this.#font = config?.font === undefined ? Theme.FontFamily : config.font;
        this.#weight = config?.weight === undefined ? FontWeight.Normal : config.weight;
        this.#fontStyle = config?.style === undefined ? FontStyle.Normal : config.style;
    }

    setupStyle(ctx: CanvasRenderingContext2D, scale: number): void {
        ctx.fillStyle = this.#color;
        ctx.font = this.#fontStyle + " " + this.#weight + " " + (this.#size * scale) + "px " + this.#font;
    }

    getSize(): number {
        return this.#size;
    }

    getFont(): string {
        return this.#font;
    }

    measure(ctx: CanvasRenderingContext2D, scale: number, text: string, out: Vector2): void {
        this.setupStyle(ctx, scale);
        const measurements = ctx.measureText(text)
        out.x = measurements.width;
        out.y = measurements.actualBoundingBoxAscent + measurements.actualBoundingBoxDescent;
    }

    setColor(color: string): void {
        this.#color = color;
    }

    getColor(): string {
        return this.#color ;
    }

    setSize(size: number): void {
        this.#size = size;
    }

    setWeight(weight: FontWeight): void {
        this.#weight = weight;
    }
}

================
File: src/styles/textBox.ts
================
import { Box } from "../types/box";
import { BoxStyle, BoxStyleConfig, BoxStyleWithFallback } from "./box";
import { TextAlign } from "./canvasTextAlign";
import { TextBaseline } from "./canvasTextBaseline";
import { TextStyle, TextStyleConfig, TextStyleFallback } from './text';


export interface TextBoxStyleConfig {
    box?: BoxStyleConfig;
    text?: TextStyleConfig;

    textAlign?: CanvasTextAlign;
    textBaseline?: CanvasTextBaseline;
}

export function TextBoxStyleWithFallback(input?: TextBoxStyleConfig, fallback?: TextBoxStyleConfig): TextBoxStyleConfig {
    return {
        box: BoxStyleWithFallback(input?.box, fallback?.box),
        text: TextStyleFallback(input?.text, fallback?.text),
        
        textAlign: input?.textAlign === undefined ? fallback?.textAlign : input?.textAlign,
        textBaseline: input?.textBaseline === undefined ? fallback?.textBaseline : input?.textBaseline,
    };
}

export class TextBoxStyle {
    #box: BoxStyle;

    #text: TextStyle;

    #textAlign: CanvasTextAlign;

    #textBaseline: CanvasTextBaseline;

    constructor(config?: TextBoxStyleConfig) {
        this.#box = new BoxStyle(config?.box);
        this.#text = new TextStyle(config?.text);

        this.#textAlign = config?.textAlign === undefined ? TextAlign.Center : config.textAlign;
        this.#textBaseline = config?.textBaseline === undefined ? TextBaseline.Middle : config.textBaseline;
    }

    Draw(ctx: CanvasRenderingContext2D, box: Box, scale: number, text: string) {
        this.#box.Draw(ctx, box, scale);

        ctx.textAlign = this.#textAlign;
        ctx.textBaseline = this.#textBaseline;
        this.#text.setupStyle(ctx, scale);

        ctx.fillText(
            text,
            box.Position.x + (box.Size.x / 2),
            box.Position.y + (box.Size.y / 2),
        );
    }

    DrawUnderline(ctx: CanvasRenderingContext2D, box: Box, scale: number, text: string) {
        this.#box.DrawUnderline(ctx, box, scale);

        ctx.textAlign = this.#textAlign;
        ctx.textBaseline = this.#textBaseline;
        this.#text.setupStyle(ctx, scale);

        ctx.fillText(
            text,
            box.Position.x + (box.Size.x / 2),
            box.Position.y + (box.Size.y / 2),
        );
    }

    setTextColor(color: string): void {
        this.#text.setColor(color);
    }

    setBoxColor(color: string): void {
        this.#box.setColor(color);
    }

    setBorderColor(color: string): void {
        this.#box.setBorderColor(color);
    }
}

================
File: src/types/box.ts
================
import { VectorPool } from "./pool";
import { AddVector2, CopyVector2, SubVector2, Vector2, Zero } from "./vector2";

export interface Box {
    Position: Vector2
    Size: Vector2
}

export function CopyBox(dst: Box, src: Box): void {
    dst.Position.x = src.Position.x;
    dst.Position.y = src.Position.y;
    dst.Size.x = src.Size.x;
    dst.Size.y = src.Size.y;
}

function normalizeMinMax(min: Vector2, max: Vector2) {
    if (min.x > max.x) {
        let temp = max.x;
        max.x = min.x;
        min.x = temp;
    }

    if (min.y > max.y) {
        let temp = max.y;
        max.y = min.y;
        min.y = temp;
    }
}

export function BoxIntersection(a: Box, b: Box): boolean {
    let intersects = false;

    VectorPool.run(() => {
        const aMin = VectorPool.get();
        const aMax = VectorPool.get();
        CopyVector2(aMin, a.Position);
        AddVector2(aMax, aMin, a.Size);
        normalizeMinMax(aMin, aMax);

        const bMin = VectorPool.get();
        const bMax = VectorPool.get();
        CopyVector2(bMin, b.Position);
        AddVector2(bMax, bMin, b.Size);
        normalizeMinMax(bMin, bMax);

        intersects = (aMin.x <= bMax.x) && (aMax.x >= bMin.x) &&
            (aMin.y <= bMax.y) && (aMax.y >= bMin.y);
    })

    return intersects;
}

// TODO: This is probably incorrect. Needs more testing
// export function ExpandBox(boxToExpand: Box, box: Box): void {
//     const newPos: Vector2 = Zero();
//     const newSize: Vector2 = Zero();

//     CopyVector2(newPos, boxToExpand.Position);
//     CopyVector2(newSize, boxToExpand.Size);


//     const positionOffset: Vector2 = Zero();

//     // Get Position Adjustment
//     SubVector2(positionOffset, box.Position, boxToExpand.Position);

//     // We only care about adjustments that make us bigger.
//     positionOffset.x = Math.min(positionOffset.x, 0);
//     positionOffset.y = Math.min(positionOffset.y, 0);

//     // Adjust our position 
//     AddVector2(boxToExpand.Position, boxToExpand.Position, positionOffset);

//     // Increase our size to take into account new position
//     SubVector2(newSize, newSize, positionOffset);

//     const sizeIncrease: Vector2 = Zero();

//     const curEndPos: Vector2 = {
//         x: boxToExpand.Position.x + boxToExpand.Size.x,
//         y: boxToExpand.Position.y + boxToExpand.Size.y,
//     };

//     const boxEndPos: Vector2 = {
//         x: box.Position.x + box.Size.x,
//         y: box.Position.y + box.Size.y,
//     };

//     SubVector2(sizeIncrease, boxEndPos, curEndPos);

//     // We only care about increases to our size
//     sizeIncrease.x = Math.max(sizeIncrease.x, 0);
//     sizeIncrease.y = Math.max(sizeIncrease.y, 0);

//     // Increase our size to take into account new position
//     SubVector2(newSize, newSize, sizeIncrease)

//     // Finally, Set result
//     CopyVector2(boxToExpand.Position, newPos)
//     CopyVector2(boxToExpand.Size, newSize)
// }

export function BoxCenter(box: Box, out: Vector2): Vector2 {
    out.x = box.Position.x + (box.Size.x / 2);
    out.y = box.Position.y + (box.Size.y / 2);
    return out
}

export function InBox(box: Box, position: Vector2): boolean {
    const min = box.Position
    if (position.x < min.x) {
        return false
    }
    if (position.y < min.y) {
        return false
    }

    if (position.x > min.x + box.Size.x) {
        return false
    }
    if (position.y > min.y + box.Size.y) {
        return false
    }

    return true
}

================
File: src/types/list.ts
================
export class List<Type> {

    #arr: Array<Type>;

    #count: number;

    constructor() {
        this.#arr = new Array<Type>();
        this.#count = 0;
    }

    public Count(): number {
        return this.#count;
    }

    public Clear(): void {
        this.#count = 0;
    }

    public At(index: number): Type {
        return this.#arr[index];
    }

    public Push(value: Type): void {
        if (this.#arr.length === this.#count) {
            this.#arr.push(value);
        } else {
            this.#arr[this.#count] = value;
        }
        this.#count++;
    }

    public ToArray(): Array<Type> {
        let arr = new Array<Type>(this.Count());
        for(let i = 0; i < this.#count; i ++) {
            arr[i] = this.#arr[i]
        }
        return arr;
    }

}

================
File: src/types/pool.ts
================
import { Vector2 } from "./vector2";



export class Pool<Type> {

    #arr: Array<Type>;

    #count: number;

    #builder: () => Type;

    #reset: (v: Type) => void;

    #runningDepth: number;

    constructor(builder: () => Type, reset: (v: Type) => void) {
        this.#arr = new Array<Type>();
        this.#count = 0;
        this.#builder = builder;
        this.#reset = reset;
        this.#runningDepth = 0;
    }

    public runIf(condition: boolean, fn: () => void) {
        if (condition) {
            this.run(fn);
        }
    }

    #running(): boolean {
        return this.#runningDepth > 0;
    }

    public run(fn: () => void) {
        const start = this.#count;
        this.#runningDepth += 1;
        fn();
        this.#runningDepth -= 1;
        this.#count = start;
        // console.log(this.#arr.length);
    }

    get(): Type {
        if(!this.#running()) {
            throw new Error("can't use pool outside of running context");
        }

        let value: Type;
        if (this.#arr.length === this.#count) {
            value = this.#builder();
            this.#arr.push(this.#builder());
        } else {
            value = this.#arr[this.#count];
            this.#reset(value);
        }
        this.#count++;
        return value;
    }

}

export const VectorPool = new Pool<Vector2>(
    () => ({ x: 0, y: 0 }),
    (v) => { v.x = 0; v.y = 0; }
)

================
File: src/types/text.ts
================
import { FontWeight, TextStyle, TextStyleConfig } from "../styles/text";
import { splitString, splitStringIntoLines } from "../utils/string";
import { CopyVector2, ScaleVector, Vector2, Zero } from "./vector2";

export class Text {

    #measured: boolean

    #size: Vector2;

    #style: TextStyle;

    #value: string

    constructor(value: string, style?: TextStyleConfig) {
        this.#value = value;
        this.#measured = false;
        this.#size = Zero();
        this.#style = new TextStyle(style);

        if (!document.fonts.check(`16px "${this.#style.getFont()}"`)) {
            document.fonts.addEventListener("loadingdone", (event) => {
                this.#measured = false;
            });
        }
    }

    set(newValue: string): void {
        this.#value = newValue;
        this.#measured = false;
    }

    get(): string {
        return this.#value;
    }

    breakIntoLines(ctx: CanvasRenderingContext2D, maxWidth: number): Array<Text> {
        const results = new Array<Text>();

        this.#style.setupStyle(ctx, 1);
        const entries = splitStringIntoLines(ctx, this.#value, maxWidth);
        if (entries.length === 1) {
            return [this];
        }
        for (let i = 0; i < entries.length; i++) {
            const text = new Text(entries[i])
            text.#style = this.#style;
            results.push(text)
        }

        return results;
    }

    split(char: string): Array<Text> {
        const entries = this.#value.split(char)
        const results = new Array<Text>();
        for (let i = 0; i < entries.length; i++) {
            const text = new Text(entries[i])
            text.#style = this.#style;
            results.push(text)
        }
        return results;
    }

    splitAtIndex(index: number): Array<Text> {
        const results = [
            new Text(this.#value.substring(0, index)),
            new Text(this.#value.substring(index, 0)),
        ];


        for (let i = 0; i < results.length; i++) {
            results[i].#style = this.#style;
        }
        return results;
    }

    splitAtWidth(ctx: CanvasRenderingContext2D, maxWidth: number): Array<Text> {
        this.#style.setupStyle(ctx, 1);
        const entries = splitString(ctx, this.#value, maxWidth);
        if (entries.length === 1) {
            return [this];
        }

        const results = new Array<Text>();
        for (let i = 0; i < entries.length; i++) {
            const text = new Text(entries[i])
            text.#style = this.#style;
            results.push(text)
        }
        return results;
    }

    #measure(ctx: CanvasRenderingContext2D): void {
        if (this.#measured) {
            return;
        }

        this.#style.setupStyle(ctx, 1);
        const measurements = ctx.measureText(this.#value);
        this.#size.x = measurements.width;
        this.#size.y = measurements.actualBoundingBoxAscent + measurements.actualBoundingBoxDescent;
        this.#measured = true;
    }

    size(ctx: CanvasRenderingContext2D, scale: number, out: Vector2): void {
        this.#measure(ctx);
        CopyVector2(out, this.#size);
        ScaleVector(out, scale);
    }

    setColor(color: string): void {
        this.#style.setColor(color);
    }
    
    getColor(): string {
        return this.#style.getColor();
    }

    setSize(size: number): void {
        this.#style.setSize(size);
    }

    setWeight(weight: FontWeight): void {
        this.#style.setWeight(weight);
    }

    render(ctx: CanvasRenderingContext2D, scale: number, position: Vector2): void {
        this.#style.setupStyle(ctx, scale)
        ctx.fillText(this.#value, position.x, position.y);
    }

    style(): TextStyle {
        return this.#style;
    }
}

================
File: src/types/vector2.ts
================
export interface Vector2 {
    x: number
    y: number
}

export function CopyVector2(dst: Vector2, src: Vector2): void {
    dst.x = src.x;
    dst.y = src.y;
}

export function SubVector2(dst: Vector2, a: Vector2, b: Vector2): void {
    dst.x = a.x - b.x;
    dst.y = a.y - b.y;
}

export function AddVector2(dst: Vector2, a: Vector2, b: Vector2): void {
    dst.x = a.x + b.x;
    dst.y = a.y + b.y;
}

export function ScaleVector(dst: Vector2, scale: number): void {
    dst.x *= scale;
    dst.y *= scale;
}

export function Zero(): Vector2 {
    return { x: 0, y: 0 };
}

export function Distance(a: Vector2, b: Vector2): number { 
    const xd = b.x - a.x
    const yd = b.y - a.y
    return Math.sqrt((xd*xd)+(yd*yd))
}

================
File: src/utils/color.ts
================
import { Clamp01 } from './math';

export interface Color {
    r: number, // 0 - 1
    g: number, // 0 - 1
    b: number, // 0 - 1
}

export interface HSV {
    h: number,  // angle in degrees
    s: number,  // 0 - 1
    v: number,  // 0 - 1
}

function componentToHex(c: number) {
    var hex = c.toString(16);
    return hex.length == 1 ? "0" + hex : hex;
}

export function RgbToHex(c: Color): string {
    return "#" + componentToHex(Math.round(c.r * 255)) + componentToHex(Math.round(c.g * 255)) + componentToHex(Math.round(c.b * 255));
}

export function HexToColor(hex: string): Color | null {
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16) / 255,
        g: parseInt(result[2], 16) / 255,
        b: parseInt(result[3], 16) / 255
    } : null;
}


export function HSV2RGB(hsv: HSV, out: Color): void {
    if (hsv.s <= 0.0) {       // < is bogus, just shuts up warnings
        out.r = hsv.v;
        out.g = hsv.v;
        out.b = hsv.v;
        return;
    }
    let hh = hsv.h;
    if (hh >= 360.0) {
        hh = 0.0;
    }
    hh /= 60.0;

    const i = Math.round(hh);
    const ff = hh - i;
    const p = hsv.v * (1.0 - hsv.s);
    const q = hsv.v * (1.0 - (hsv.s * ff));
    const t = hsv.v * (1.0 - (hsv.s * (1.0 - ff)));

    switch (i) {
        case 0:
            out.r = hsv.v;
            out.g = t;
            out.b = p;
            break;
        case 1:
            out.r = q;
            out.g = hsv.v;
            out.b = p;
            break;
        case 2:
            out.r = p;
            out.g = hsv.v;
            out.b = t;
            break;

        case 3:
            out.r = p;
            out.g = q;
            out.b = hsv.v;
            break;
        case 4:
            out.r = t;
            out.g = p;
            out.b = hsv.v;
            break;
        // case 5:
        default:
            out.r = hsv.v;
            out.g = p;
            out.b = q;
            break;
    }

    out.r = Clamp01(out.r)
    out.g = Clamp01(out.g)
    out.b = Clamp01(out.b)
}

export function RGB2HSV(rgb: Color, out: HSV): void {
    out.h = 0;
    out.s = 0;
    out.v = 0;
    let min: number = 0;
    let max: number = 0;
    let delta: number = 0;

    min = rgb.r < rgb.g ? rgb.r : rgb.g;
    min = min < rgb.b ? min : rgb.b;

    max = rgb.r > rgb.g ? rgb.r : rgb.g;
    max = max > rgb.b ? max : rgb.b;

    out.v = max;                                // v
    delta = max - min;
    if (delta < 0.00001) {
        out.s = 0;
        out.h = 0; // undefined, maybe nan?
        return;
    }
    if (max > 0.0) { // NOTE: if Max is == 0, this divide would cause a crash
        out.s = (delta / max);                  // s
    } else {
        // if max is 0, then r = g = b = 0              
        // s = 0, h is undefined
        out.s = 0.0;
        out.h = NaN;                            // its now undefined
        return;
    }
    if (rgb.r >= max)                           // > is bogus, just keeps compilor happy
        out.h = (rgb.g - rgb.b) / delta;        // between yellow & magenta
    else
        if (rgb.g >= max)
            out.h = 2.0 + (rgb.b - rgb.r) / delta;  // between cyan & yellow
        else
            out.h = 4.0 + (rgb.r - rgb.g) / delta;  // between magenta & cyan

    out.h *= 60.0;                              // degrees

    if (out.h < 0.0)
        out.h += 360.0;

}

================
File: src/utils/html.ts
================
export function HtmlFromString(htmlString: string): Element {
    var div = document.createElement('div');
    div.innerHTML = htmlString;
    const child = div.firstElementChild;
    if (child === null || child === undefined) {
        throw new Error("unable to create html from string")
    }
    return child;
}

interface CSS {
    [name: string]: any
}

export function CssToString(css: CSS): string {
    let cssString = ""
    for (let entry in css) {
        cssString += entry + ":" + css[entry] + ";";
    }
    return cssString;
}

================
File: src/utils/math.ts
================
export function Clamp(v: number, min: number, max: number): number {
    return Math.min(Math.max(v, min), max)
}

export function Clamp01(v: number): number {
    return Clamp(v, 0, 1);
}

================
File: src/utils/string.ts
================
const binarySearch = ({ max, getValue, match }) => {
    let min = 0;

    while (min <= max) {
        let guess = Math.floor((min + max) / 2);
        const compareVal = getValue(guess);

        if (compareVal === match) return guess;
        if (compareVal < match) min = guess + 1;
        else max = guess - 1;
    }

    return max;
};

export function fitString(ctx: CanvasRenderingContext2D, str: string, maxWidth: number): string {
    let width = ctx.measureText(str).width;
    const ellipsis = '';
    const ellipsisWidth = ctx.measureText(ellipsis).width;
    if (width <= maxWidth || width <= ellipsisWidth) {
        return str;
    }

    const index = binarySearch({
        max: str.length,
        getValue: guess => ctx.measureText(str.substring(0, guess)).width,
        match: maxWidth - ellipsisWidth,
    });

    return str.substring(0, index) + ellipsis;
};

export function splitString(ctx: CanvasRenderingContext2D, str: string, maxWidth: number): Array<string> {
    let width = ctx.measureText(str).width;
    if (width <= maxWidth) {
        return [str];
    }

    let index = binarySearch({
        max: str.length,
        getValue: guess => ctx.measureText(str.substring(0, guess)).width,
        match: maxWidth,
    });

    for (let backward = index - 1; backward >= 1; backward--) {
        if (str.charAt(backward) === " ") {
            index = backward + 1;
            break;
        }
    }

    return [str.substring(0, index), str.substring(index)];
};


export function splitStringIntoLines(ctx: CanvasRenderingContext2D, str: string, maxWidth: number): Array<string> {
    let width = ctx.measureText(str).width;
    if (width <= maxWidth) {
        return [str];
    }

    const strings = new Array<string>;
    let remaining = str;
    while (remaining !== "") {
        let index = binarySearch({
            max: remaining.length,
            getValue: guess => ctx.measureText(remaining.substring(0, guess)).width,
            match: maxWidth,
        });

        if (index === remaining.length) {
            strings.push(remaining.substring(0, index))
            break;
        }

        for (let backward = index - 1; backward >= 1; backward--) {
            if (remaining.charAt(backward) === " ") {
                index = backward + 1;
                break;
            }
        }

        strings.push(remaining.substring(0, index))
        remaining = remaining.substring(index)
    }

    return strings;
};

// https://stackoverflow.com/a/18234317/4974261
export function Format(str: string, ...args: Array<string>): string {
    if (arguments.length) {
        for (let key in args) {
            str = str.replace(new RegExp("\\{" + key + "\\}", "gi"), args[key]);
        }
    }
    return str;
};

================
File: src/widgets/button.ts
================
import { Theme } from "../theme";
import { TextBoxStyle, TextBoxStyleConfig, TextBoxStyleWithFallback } from "../styles/textBox";
import { Box, InBox } from "../types/box";
import { CopyVector2, Vector2 } from "../types/vector2";
import { height, width } from "./widget";


export interface ButtonWidgetConfig {
    text?: string;
    callback?: () => void;
    idleStyle?: TextBoxStyleConfig;
    hoverStyle?: TextBoxStyleConfig;
    clickStyle?: TextBoxStyleConfig;
}

export class ButtonWidget {

    #text: string;

    #idleStyle: TextBoxStyle;

    #hoverStyle: TextBoxStyle;

    #clickStyle: TextBoxStyle;

    #callback?: () => void;

    #gettingClicked: boolean;

    constructor(config?: ButtonWidgetConfig) {
        this.#text = config?.text === undefined ? "Button" : config?.text;
        this.#callback = config?.callback
        this.#gettingClicked = false;

        this.#idleStyle = new TextBoxStyle(TextBoxStyleWithFallback(config?.idleStyle, {
            box: {
                color: Theme.Widget.BackgroundColor,
                border: {
                    size: Theme.Widget.Border.Size,
                    color: Theme.Widget.Border.Color,
                }
            },
            text: { color: Theme.Widget.FontColor },
        }));
        this.#hoverStyle = new TextBoxStyle(TextBoxStyleWithFallback(config?.hoverStyle, {
            box: {
                color: Theme.Widget.Hover.BackgroundColor,
                border: {
                    size: Theme.Widget.Border.Size,
                    color: Theme.Widget.Border.Color,
                }
            },
            text: { color: Theme.Widget.FontColor },
        }));
        this.#clickStyle = new TextBoxStyle(TextBoxStyleWithFallback(config?.clickStyle, {
            box: { 
                color: Theme.Widget.Button.Click.BackgroundColor,
                border: {
                    size: Theme.Widget.Border.Size,
                    color: Theme.Widget.Border.Color,
                }
            },
            text: { color: Theme.Widget.FontColor },
        }))
    }

    Size(): Vector2 {
        return { "x": width, "y": height }
    }

    Draw(ctx: CanvasRenderingContext2D, position: Vector2, scale: number, mousePosition: Vector2 | undefined): Box {
        const box = {
            Position: { x: 0, y: 0 },
            Size: {
                x: width * scale,
                y: height * scale
            }
        };
        CopyVector2(box.Position, position);

        let style: TextBoxStyle = this.#idleStyle;

        if (mousePosition !== undefined && !this.#gettingClicked) {
            if (InBox(box, mousePosition)) {
                style = this.#hoverStyle;
            }
        }

        if (this.#gettingClicked) {
            style = this.#clickStyle;
        }
        style.Draw(ctx, box, scale, this.#text);

        return box
    }

    ClickStart(): void {
        this.#gettingClicked = true;
    }

    ClickEnd(): void {
        this.#gettingClicked = false;
        if (this.#callback !== undefined) {
            this.#callback();
        }
    }
}

================
File: src/widgets/color.ts
================
import { HexToColor } from "../utils/color";
import { TextStyleConfig } from "../styles/text";
import { Box } from "../types/box";
import { CopyVector2, Vector2 } from "../types/vector2";
import { height, width } from "./widget";
import { Popup } from "../popup";
import { TextBoxStyle } from '../styles/textBox';
import { Theme } from "../theme";
import { FlowNode } from "../node";

export interface ColorWidgetConfig {
    value?: string;

    property?: string;

    textStyle?: TextStyleConfig;

    callback?: (newColor: string) => void;
}

function contrastColor(color: string): string {
    const c = HexToColor(color);
    if (c === null) {
        return "black";
    }

    if ((c.r + c.g + c.b) / 3 > 0.5) {
        return "black"
    }

    return "white";
}

export class ColorWidget {

    #node: FlowNode;

    #nodeProperty: string | undefined;

    #value: string;

    #contrast: string;

    #textBoxStyle: TextBoxStyle;

    #callback?: (newColor: string) => void;

    constructor(node: FlowNode, config?: ColorWidgetConfig) {
        this.#value = "#000000"
        this.#contrast = contrastColor(this.#value);
        this.Set(config?.value === undefined ? "#000000" : config?.value);
        
        this.#node = node;
        this.#nodeProperty = config?.property;
        this.#textBoxStyle = new TextBoxStyle({
            box: {
                color: this.#value,
                border: {
                    color: this.#contrast,
                    size: Theme.Widget.Border.Size
                }
            },
            text: config?.textStyle
        });
        this.#callback = config?.callback;

        if (this.#nodeProperty !== undefined) {
            this.#node.addPropertyChangeListener(this.#nodeProperty, (oldVal, newVal) => {
                this.Set(newVal);
            });
        }
    }

    Size(): Vector2 {
        return { "x": width, "y": height }
    }

    Set(value: string): void {
        if (this.#value === value) {
            return;
        }

        this.#value = value;

        if (this.#callback !== undefined) {
            this.#callback(this.#value);
        }

        if (this.#nodeProperty !== undefined) {
            this.#node.setProperty(this.#nodeProperty, this.#value);
        }

        // Update Styling
        this.#contrast = contrastColor(this.#value);
        this.#textBoxStyle.setBoxColor(this.#value);
        this.#textBoxStyle.setBorderColor(this.#contrast);
        this.#textBoxStyle.setTextColor(this.#contrast);
    }

    ClickStart(): void {
    }

    ClickEnd(): void {
        let input: HTMLInputElement | null = null;

        const popup = new Popup({
            title: "Set Color",
            options: ["Set", "Cancel"],
            content: () => {
                const container = document.createElement('div');

                input = document.createElement('input')
                input.type = "color";
                input.value = this.#value;
                input.name = "color"
                container.append(input);

                const label = document.createElement("label");
                label.htmlFor = "color";
                label.textContent = "Color";
                container.append(label);

                return container;
            },
            onClose: (button: string | null): void => {
                if (button !== "Set" || input === null) {
                    return;
                }

                this.Set(input.value);
            },
        });

        popup.Show();
    }

    Draw(ctx: CanvasRenderingContext2D, position: Vector2, scale: number, mousePosition: Vector2 | undefined): Box {
        const box = {
            Position: { x: 0, y: 0 },
            Size: {
                x: width * scale,
                y: height * scale
            }
        };
        CopyVector2(box.Position, position);

        this.#textBoxStyle.Draw(ctx, box, scale, this.#value)

        return box;
    }
}

================
File: src/widgets/factory.ts
================
import { Widget } from "./widget";
import { NumberWidget, NumberWidgetConfig } from './number';
import { ButtonWidget, ButtonWidgetConfig } from './button';
import { ColorWidget, ColorWidgetConfig } from './color';
import { SliderWidget, SliderWidgetConfig } from './slider';
import { StringWidget, StringWidgetConfig } from './string';
import { ToggleWidget, ToggleWidgetConfig } from './toggle';
import { FlowNode } from "../node";
import { ImageWidget, ImageWidgetConfig } from "./image";
import { TextWidget, TextWidgetConfig } from "./text";

export type WidgetBuilder = (node: FlowNode, confg?: any) => Widget;

class WidgetFactory {

    #registeredWidgets: Map<string, WidgetBuilder>

    constructor() {
        this.#registeredWidgets = new Map<string, WidgetBuilder>();
    }

    register(widgetType: string, builder: WidgetBuilder): void {
        this.#registeredWidgets.set(widgetType, builder);
    }

    create(node: FlowNode, widgetType: string, config: any): Widget {
        const builder = this.#registeredWidgets.get(widgetType)
        if (builder === undefined) {
            throw new Error("no builder registered for widget: " + widgetType);
        }
        return builder(node, config);
    }
}

const GlobalWidgetFactory = new WidgetFactory();

GlobalWidgetFactory.register("button", (node: FlowNode, config?: ButtonWidgetConfig) => new ButtonWidget(config));
GlobalWidgetFactory.register("number", (node: FlowNode, config?: NumberWidgetConfig) => new NumberWidget(node, config));
GlobalWidgetFactory.register("color", (node: FlowNode, config?: ColorWidgetConfig) => new ColorWidget(node, config));
GlobalWidgetFactory.register("slider", (node: FlowNode, config?: SliderWidgetConfig) => new SliderWidget(node, config));
GlobalWidgetFactory.register("string", (node: FlowNode, config?: StringWidgetConfig) => new StringWidget(node, config));
GlobalWidgetFactory.register("toggle", (node: FlowNode, config?: ToggleWidgetConfig) => new ToggleWidget(node, config));
GlobalWidgetFactory.register("image", (node: FlowNode, config?: ImageWidgetConfig) => new ImageWidget(config));
GlobalWidgetFactory.register("text", (node: FlowNode, config?: TextWidgetConfig) => new TextWidget(node, config));

export { GlobalWidgetFactory };

================
File: src/widgets/image.ts
================
import { Box } from "../types/box";
import { CopyVector2, Vector2 } from "../types/vector2";

const margin = 15;

export interface ImageWidgetConfig {
    image?: string;
    maxWidth?: number
    maxHeight?: number
    blob?: Blob;
}

/**
 *   constructor(lightNode, nodeManager, id, parameterData, app) {
        this.lightNode = lightNode;
        this.id = id;
        this.app = app;
        this.lightNode.title = parameterData.name;

        this.lightNode.onDropFile = (file) => {
            // console.log(file)
            var reader = new FileReader();
            reader.onload = (evt) => {
                console.log(evt.target.result)
                nodeManager.nodeParameterChanged({
                    id: id,
                    data: evt.target.result,
                    binary: true
                });
            }
            reader.readAsArrayBuffer(file);

            const url = URL.createObjectURL(file);
            // this.loadImage(this._url, function (img) {
            //     that.size[1] = (img.height / img.width) * that.size[0];
            // });
            this.loadImgFromURL(url);
        }
    }

    loadImgFromURL(url) {
        const img = document.createElement("img");
        img.src = url;
        img.onload = () => {
            // if (callback) {
            // callback(this);
            // }
            // console.log("Image loaded, size: " + img.width + "x" + img.height);
            // this.dirty = true;
            // that.boxcolor = "#9F9";f
            // that.setDirtyCanvas(true);
            this.lightNode.widgets[0].image = img
            this.lightNode.setSize(this.lightNode.computeSize());
        };
        img.onerror = () => {
            console.log("error loading the image:" + url);
        }
    }

    update(parameterData) {
        console.log("image parameter", parameterData)
        const curVal = parameterData.currentValue;
        this.app.RequestManager.getParameterValue(this.id, (response) => {
            const url = URL.createObjectURL(response);
            this.loadImgFromURL(url)
        })
    }
 */

export class ImageWidget {

    #url: string | undefined;

    #image: HTMLImageElement | undefined;

    #maxWidth: number;

    #maxHeight: number;

    constructor(config?: ImageWidgetConfig) {
        this.#maxWidth = config?.maxWidth === undefined ? 150 : config?.maxWidth;
        this.#maxHeight = config?.maxHeight === undefined ? 150 : config?.maxHeight;
        if (config?.image) {
            this.SetUrl(config?.image);
        } else if (config?.blob) {
            this.SetBlob(config?.blob);
        }
    }

    SetBlob(blob: Blob) {
        const urlCreator = window.URL || window.webkitURL;
        const imageUrl = urlCreator.createObjectURL(blob);
        this.SetUrl(imageUrl);
    }

    SetUrl(url: string) {
        this.#image = undefined;
        this.#url = url;

        const img = document.createElement("img");
        img.src = url;
        img.onload = () => {
            this.#image = img;
        };
        img.onerror = (event) => {
            console.log("error loading image:", url, event);
        }
    }

    Size(): Vector2 {
        if (this.#image === undefined) {
            return { "x": 0, "y": 0 }
        }

        let adjust = 1;
        if (this.#image.width > this.#maxWidth) {
            adjust = this.#maxWidth / this.#image.width
        }

        if (this.#image.height > this.#maxHeight) {
            let heightAdjust = this.#maxHeight / this.#image.height
            if (heightAdjust < adjust) {
                adjust = heightAdjust;
            }
        }

        return {
            "x": adjust * this.#image.width,
            "y": adjust * this.#image.height
        }
    }

    ClickStart(): void {
    }

    ClickEnd(): void {
    }

    Draw(ctx: CanvasRenderingContext2D, position: Vector2, scale: number, mousePosition: Vector2 | undefined): Box {
        const size = this.Size();
        const box: Box = {
            Position: { x: 0, y: 0 },
            Size: {
                x: size.x * scale,
                y: size.y * scale,
            }
        }
        CopyVector2(box.Position, position);

        if (!this.#image) {
            return box;
        }

        ctx.drawImage(
            this.#image,
            position.x,
            position.y,
            box.Size.x,
            box.Size.y
        );
        return box;
    }
}

================
File: src/widgets/number.ts
================
import { Theme } from "../theme";
import { Popup } from "../popup";
import { TextBoxStyle, TextBoxStyleConfig, TextBoxStyleWithFallback } from "../styles/textBox";
import { Box, InBox } from '../types/box';
import { CopyVector2, Vector2 } from "../types/vector2";
import { height, width } from "./widget";
import { FlowNode } from "../node";

export interface NumberWidgetConfig {
    value?: number;

    property?: string;

    idleBoxStyle?: TextBoxStyleConfig;

    highlightBoxStyle?: TextBoxStyleConfig;

    callback?: (newNumber: number) => void;
}

export class NumberWidget {

    #node: FlowNode;

    #nodeProperty: string | undefined;

    #value: number;

    #idleBoxStyle: TextBoxStyle;

    #highlightBoxStyle: TextBoxStyle;

    #text: string;

    #callback?: (newNumber: number) => void;

    constructor(node: FlowNode, config?: NumberWidgetConfig) {
        this.#value = 0;
        this.#text = "0";

        this.#node = node;
        this.#nodeProperty = config?.property;
        this.#idleBoxStyle = new TextBoxStyle(TextBoxStyleWithFallback(config?.idleBoxStyle, {
            box: {
                color: Theme.Widget.BackgroundColor,
                border: {
                    size: Theme.Widget.Border.Size,
                    color: Theme.Widget.Border.Color,
                },
                radius: Theme.Widget.Border.Radius
            },
            text: { color: Theme.Widget.FontColor },
        }));
        this.#highlightBoxStyle = new TextBoxStyle(TextBoxStyleWithFallback(config?.highlightBoxStyle, {
            box: {
                color: Theme.Widget.Hover.BackgroundColor,
                border: {
                    size: Theme.Widget.Border.Size,
                    color: Theme.Widget.Border.Color,
                },
                radius: Theme.Widget.Border.Radius
            },
            text: { color: Theme.Widget.FontColor },
        }));
        this.Set(config?.value === undefined ? 0 : config?.value);
        this.#callback = config?.callback;

        if (this.#nodeProperty !== undefined) {
            this.#node.addPropertyChangeListener(this.#nodeProperty, (oldVal, newVal) => {
                this.Set(newVal);
            });
        }

    }

    Size(): Vector2 {
        return { "x": width, "y": height }
    }

    Set(newNumber: number): void {
        if (this.#value === newNumber) {
            return;
        }

        this.#value = newNumber;

        if (this.#nodeProperty !== undefined) {
            this.#node.setProperty(this.#nodeProperty, this.#value);
        }

        if (this.#callback !== undefined) {
            this.#callback(this.#value);
        }

        // https://stackoverflow.com/questions/5765398/whats-the-best-way-to-convert-a-number-to-a-string-in-javascript
        this.#text = '' + parseFloat(this.#value.toPrecision(6));
    }

    ClickStart(): void {
    }

    ClickEnd(): void {
        let input: HTMLInputElement | null = null;

        const setOption = "Set";
        const cancelOption = "Cancel";
        const popup = new Popup({
            title: "Set Number",
            options: [setOption, cancelOption],
            content: () => {
                const container = document.createElement('div');
                input = document.createElement('input')
                input.type = "number";
                input.valueAsNumber = this.#value;
                container.append(input);
                return container;
            },
            onClose: (button: string | null): void => {
                if (button !== setOption || input === null) {
                    return;
                }

                this.Set(input.valueAsNumber);
            },
        });

        popup.Show();
    }


    Draw(ctx: CanvasRenderingContext2D, position: Vector2, scale: number, mousePosition: Vector2 | undefined): Box {
        const box = {
            Position: { x: 0, y: 0 },
            Size: {
                x: width * scale,
                y: height * scale
            }
        };
        CopyVector2(box.Position, position);

        let style: TextBoxStyle = this.#idleBoxStyle;

        if (mousePosition !== undefined) {
            if (InBox(box, mousePosition)) {
                style = this.#highlightBoxStyle;
            }
        }

        style.DrawUnderline(ctx, box, scale, this.#text)

        return box;
    }
}

================
File: src/widgets/slider.ts
================
import { Theme } from "../theme";
import { TextAlign } from "../styles/canvasTextAlign";
import { TextStyle, TextStyleConfig, TextStyleFallback } from "../styles/text";
import { Box } from '../types/box';
import { CopyVector2, Vector2, Zero } from "../types/vector2";
import { Clamp, Clamp01 } from "../utils/math";
import { height, width } from "./widget";
import { TextBaseline } from "../styles/canvasTextBaseline";
import { FlowNode } from "../node";

export interface SliderWidgetConfig {

    property?: string;

    min?: number;

    max?: number;

    value?: number;

    backgroundColor?: string;

    borderColor?: string;

    fillColor?: string;

    textStyle?: TextStyleConfig;

    change?: (newValue: number) => void;

    release?: (newValue: number) => void;

    snapIncrement?: number;

}

export class SliderWidget {

    // Data Variables =========================================================

    #min: number;

    #max: number;

    #value: number;

    #text: string;

    #snapIncrement?: number;

    #node: FlowNode;

    #nodeProperty: string | undefined;

    // Callbacks ==============================================================

    #change?: (newValue: number) => void;

    #release?: (newValue: number) => void;

    // Styling Variables ======================================================

    #textStyle: TextStyle

    #backgroundColor: string;

    #borderColor: string;

    #fillColor: string;

    // Runtime Variables ======================================================

    #lastMousePosition: Vector2;

    #clickStartMousePosition: Vector2;

    #clicking: boolean;

    constructor(node: FlowNode, config?: SliderWidgetConfig) {
        this.#node = node;
        this.#value = 0;
        this.#min = config?.min === undefined ? 0 : config?.min;
        this.#max = config?.max === undefined ? 1 : config?.max;
        this.#snapIncrement = config?.snapIncrement;
        this.#nodeProperty = config?.property;
        this.#text = "";
        
        this.#release = config?.release;

        this.#backgroundColor = config?.backgroundColor === undefined ? Theme.Widget.BackgroundColor : config?.backgroundColor;
        this.#fillColor = config?.fillColor === undefined ? Theme.Widget.Slider.FillColor : config?.fillColor;
        this.#borderColor = config?.borderColor === undefined ? Theme.Widget.Border.Color : config?.borderColor;
        this.#textStyle = new TextStyle(TextStyleFallback(config?.textStyle, {
            color: Theme.Widget.FontColor,
        }));
        this.#lastMousePosition = Zero();
        this.#clickStartMousePosition = Zero();
        this.#clicking = false;


        if (config?.property !== undefined && config?.property !== null) {
            node.addPropertyChangeListener(config.property, (oldVal, newVal) => {
                this.SetValue(newVal);
            });
        }

        this.SetValue(config?.value === undefined ? 0 : config?.value);

        // Setup change callback after we set the initial value to prevent the callback from being 
        this.#change = config?.change;
    }

    SetValue(newValue: number): void {
        const cleanedValue = Clamp(newValue, this.#min, this.#max);
        if (this.#value === cleanedValue) {
            return;
        }

        this.#value = cleanedValue;

        if (this.#nodeProperty) {
            this.#node.setProperty(this.#nodeProperty, this.#value);
        }

        this.#text = this.#value.toFixed(3);
        if (this.#change !== undefined) {
            this.#change(this.#value);
        }
    }

    Size(): Vector2 {
        return { "x": width, "y": height }
    }

    ClickStart(): void {
        this.#clicking = true;
        CopyVector2(this.#clickStartMousePosition, this.#lastMousePosition)
    }

    ClickEnd(): void {
        this.#clicking = false;
        if (this.#release !== undefined) {
            this.#release(this.#value);
        }
    }

    Draw(ctx: CanvasRenderingContext2D, position: Vector2, scale: number, mousePosition: Vector2 | undefined): Box {
        const scaledWidth = width * scale;
        const scaledHeight = height * scale;

        const scaledBorderThickness = Theme.Widget.Border.Size * scale;

        // Render background
        ctx.fillStyle = this.#backgroundColor;
        ctx.strokeStyle = this.#borderColor;
        ctx.lineWidth = scaledBorderThickness;
        ctx.beginPath();
        ctx.roundRect(
            position.x,
            position.y,
            scaledWidth,
            scaledHeight,
            Theme.Widget.Border.Radius * scale
        );
        ctx.fill();
        ctx.stroke();

        // Render Fill
        const fill = Clamp01((this.#value - this.#min) / (this.#max - this.#min));
        ctx.fillStyle = this.#fillColor;
        ctx.beginPath();
        ctx.roundRect(
            position.x + (scaledBorderThickness / 2),
            position.y + (scaledBorderThickness / 2),
            (scaledWidth * fill) - scaledBorderThickness,
            scaledHeight - scaledBorderThickness,
            Theme.Widget.Border.Radius * scale
        );
        ctx.fill();

        // Render Number
        ctx.textAlign = TextAlign.Center;
        ctx.textBaseline = TextBaseline.Middle;
        this.#textStyle.setupStyle(ctx, scale);
        ctx.fillText(
            this.#text,
            position.x + (scaledWidth / 2),
            position.y + (scaledHeight / 2),
        );

        // Update value based on mouse position
        if (mousePosition !== undefined) {
            CopyVector2(this.#lastMousePosition, mousePosition);
            if (this.#clicking) {
                const min = position.x + (scaledBorderThickness / 2);
                const max = min + scaledWidth - scaledBorderThickness;
                const p = Clamp01((this.#lastMousePosition.x - min) / (max - min));

                let value = (p * (this.#max - this.#min)) + this.#min;
                if (this.#snapIncrement !== undefined) {
                    value = Math.round(value / this.#snapIncrement) * this.#snapIncrement;
                }

                this.SetValue(value);
            }
        }

        return {
            Position: { x: position.x, y: position.y },
            Size: {
                x: scaledWidth,
                y: scaledHeight
            }
        };
    }
}

================
File: src/widgets/string.ts
================
import { Theme } from "../theme";
import { TextBoxStyle, TextBoxStyleConfig, TextBoxStyleWithFallback } from "../styles/textBox";
import { Box, InBox } from "../types/box";
import { CopyVector2, Vector2 } from "../types/vector2";
import { fitString } from "../utils/string";
import { height, width } from "./widget";
import { FlowNode } from '../node';
import { SetStringPopup } from "../popups/string";

export interface StringWidgetConfig {
    property?: string;

    value?: string;

    textBoxStyle?: TextBoxStyleConfig;

    callback?: (newString: string) => void;
}

export class StringWidget {

    #value: string;

    #idleStyle: TextBoxStyle;

    #hoverStyle: TextBoxStyle;

    #callback?: (newString: string) => void;

    #node: FlowNode

    #nodeProperty: string | undefined;

    constructor(node: FlowNode, config?: StringWidgetConfig) {
        this.#value = "";
        
        this.#node = node;
        this.#nodeProperty = config?.property;
        this.#idleStyle = new TextBoxStyle(TextBoxStyleWithFallback(config?.textBoxStyle, {
            box: {
                color: Theme.Widget.BackgroundColor,
                border: {
                    size: Theme.Widget.Border.Size,
                    color: Theme.Widget.Border.Color,
                },
                radius: Theme.Widget.Border.Radius
            },
            text: { color: Theme.Widget.FontColor },
        }));

        this.#hoverStyle = new TextBoxStyle(TextBoxStyleWithFallback(config?.textBoxStyle, {
            box: {
                color: Theme.Widget.Hover.BackgroundColor,
                border: {
                    size: Theme.Widget.Border.Size,
                    color: Theme.Widget.Border.Color,
                },
                radius: Theme.Widget.Border.Radius
            },
            text: { color: Theme.Widget.FontColor },
        }));

        this.Set(config?.value === undefined ? "" : config?.value);
        this.#callback = config?.callback;
        if (this.#nodeProperty !== undefined) {
            this.#node.addPropertyChangeListener(this.#nodeProperty, (oldVal, newVal) => {
                this.Set(newVal);
            });
        }
    }

    Size(): Vector2 {
        return { "x": width, "y": height }
    }

    Set(value: string): void {
        if (this.#value === value) {
            return;
        }
        this.#value = value;

        if (this.#nodeProperty !== undefined) {
            this.#node.setProperty(this.#nodeProperty, this.#value)
        }

        if (this.#callback !== undefined) {
            this.#callback(this.#value);
        }
    }

    ClickStart(): void {
    }

    ClickEnd(): void {
        const popup = SetStringPopup({
            title: "Set String",
            startingValue: this.#value,
            onUpdate: (value: string): void => {
                this.Set(value);
            },
        });
        popup.Show();
    }

    Draw(ctx: CanvasRenderingContext2D, position: Vector2, scale: number, mousePosition: Vector2 | undefined): Box {
        const box = {
            Position: { x: 0, y: 0 },
            Size: {
                x: width * scale,
                y: height * scale
            }
        };
        CopyVector2(box.Position, position);


        let style: TextBoxStyle = this.#idleStyle;

        if (mousePosition !== undefined) {
            if (InBox(box, mousePosition)) {
                style = this.#hoverStyle;
            }
        }

        style.DrawUnderline(ctx, box, scale, fitString(ctx, this.#value, box.Size.x - (20 * scale)))

        return box;
    }
}

================
File: src/widgets/text.ts
================
import { Theme } from "../theme";
import { Box, InBox } from "../types/box";
import { CopyVector2, Vector2, Zero } from "../types/vector2";
import { FlowNode } from '../node';
import { Text } from "../types/text";
import { TextStyle, TextStyleConfig, TextStyleFallback } from "../styles/text";

export interface TextWidgetConfig {
    property?: string;

    value?: string;

    textBoxStyle?: TextStyleConfig;

    callback?: (newString: string) => void;
}

export class TextWidget {

    #value: Text;

    #callback?: (newString: string) => void;

    #node: FlowNode

    #nodeProperty: string | undefined;

    #size: Vector2;

    constructor(node: FlowNode, config?: TextWidgetConfig) {
        this.#size = Zero();
        this.#node = node;
        this.#nodeProperty = config?.property;
        this.#value = new Text("", TextStyleFallback(config?.textBoxStyle, {
            font: Theme.FontFamily,
            color: Theme.Widget.FontColor,
            size: Theme.Note.FontSize,
        }))

        this.Set(config?.value === undefined ? "" : config?.value);
        this.#callback = config?.callback;
        if (this.#nodeProperty !== undefined) {
            this.#node.addPropertyChangeListener(this.#nodeProperty, (oldVal, newVal) => {
                this.Set(newVal);
            });
        }
    }

    Size(): Vector2 {
        return this.#size;
    }

    Set(value: string): void {
        if (this.#value.get() === value) {
            return;
        }
        this.#value.set(value);

        if (this.#nodeProperty !== undefined) {
            this.#node.setProperty(this.#nodeProperty, value)
        }

        if (this.#callback !== undefined) {
            this.#callback(value);
        }
    }

    ClickStart(): void {
        // Left blank for implementing Widget interface
    }

    ClickEnd(): void {
        // Left blank for implementing Widget interface
    }


    Draw(ctx: CanvasRenderingContext2D, position: Vector2, scale: number, mousePosition: Vector2 | undefined): Box {
        this.#value.size(ctx, scale, this.#size);
        const box = {
            Position: { x: 0, y: 0 },
            Size: this.#size
        };
        CopyVector2(box.Position, position);
        this.#value.size(ctx, 1, this.#size);
        
        ctx.textAlign = "left";
        this.#value.render(ctx, scale, box.Position);
        // this.#idleStyle.DrawUnderline(ctx, box, scale, fitString(ctx, this.#value, box.Size.x - (20 * scale)))

        return box;
    }
}

================
File: src/widgets/toggle.ts
================
import { Theme } from "../theme";
import { Box, InBox } from "../types/box";
import { CopyVector2, Vector2 } from "../types/vector2";
import { height, width } from "./widget";
import { TextBoxStyle, TextBoxStyleConfig, TextBoxStyleWithFallback } from "../styles/textBox";
import { FlowNode } from "../node";

export interface ToggleStyleConfig {
    idle?: TextBoxStyleConfig,
    hover?: TextBoxStyleConfig,
    lightColor?: string;
    lightBorderColor?: string;
    lightBlur?: number;
}

export interface ToggleWidgetConfig {
    property?: string;
    value?: boolean;
    text?: string;
    callback?: () => void;
    enabledStyle?: ToggleStyleConfig;
    disabledStyle?: ToggleStyleConfig;
}

class ToggleStyle {

    #idleStyle: TextBoxStyle;

    #hoverStyle: TextBoxStyle;

    #lightColor: string;

    #lightBorderColor: string;

    #lightBlur?: number;

    #box: Box;

    constructor(config?: ToggleStyleConfig) {
        this.#idleStyle = new TextBoxStyle(TextBoxStyleWithFallback(config?.idle, {
            box: {
                color: Theme.Widget.BackgroundColor,
                border: {
                    size: Theme.Widget.Border.Size,
                    color: Theme.Widget.Border.Color,
                }
            },
            text: { color: Theme.Widget.FontColor },
        }));
        this.#hoverStyle = new TextBoxStyle(TextBoxStyleWithFallback(config?.hover, {
            box: {
                color: Theme.Widget.Hover.BackgroundColor,
                border: {
                    size: Theme.Widget.Border.Size,
                    color: Theme.Widget.Border.Color,
                }
            },
            text: { color: Theme.Widget.FontColor },
        }));
        this.#lightColor = config?.lightColor === undefined ? "#222222" : config.lightColor;
        this.#lightBorderColor = config?.lightBorderColor === undefined ? "black" : config.lightBorderColor;
        this.#lightBlur = config?.lightBlur;

        this.#box = {Position: { x: 0, y: 0 }, Size: { x: 0, y: 0 } };
    }

    Draw(ctx: CanvasRenderingContext2D, pos: Vector2, scale: number, text: string, mousePosition: Vector2 | undefined): Box {
        const scaledWidth = width * scale;
        const scaledHeight = height * scale;
        this.#box.Size.x = scaledWidth;
        this.#box.Size.y = scaledHeight;
        CopyVector2(this.#box.Position, pos);

        // Background
        let style: TextBoxStyle = this.#idleStyle;
        if (mousePosition !== undefined) {
            if (InBox(this.#box, mousePosition)) {
                style = this.#hoverStyle;
            }
        }
        style.Draw(ctx, this.#box, scale, text);

        // Light
        const lightScale = Math.min(scaledWidth, scaledHeight);
        ctx.strokeStyle = this.#lightBorderColor;
        ctx.fillStyle = this.#lightColor
        ctx.beginPath();
        ctx.roundRect(
            pos.x + (lightScale * .2),
            pos.y + (lightScale * .2),
            lightScale * .6,
            lightScale * .6,
            Theme.Widget.Border.Radius * scale
        );
        if (this.#lightBlur) {
            ctx.shadowBlur = this.#lightBlur * scale;
            ctx.shadowColor = this.#lightColor;
        }
        ctx.fill();
        if (this.#lightBlur) {
            ctx.shadowBlur = 0;
        }
        // ctx.stroke();

        return this.#box
    }
}

export class ToggleWidget {

    #node: FlowNode;

    #nodeProperty: string | undefined;

    #value: boolean;

    #text: string;

    #enabledStyle: ToggleStyle;

    #disabledStyle: ToggleStyle;

    #callback?: (value: boolean) => void;

    constructor(node: FlowNode, config?: ToggleWidgetConfig) {
        this.#value = false;

        this.#node = node;
        this.#nodeProperty = config?.property;
        this.#text = config?.text === undefined ? "Toggle" : config?.text;

        this.#enabledStyle = new ToggleStyle({
            idle: TextBoxStyleWithFallback(config?.enabledStyle?.idle, {
                box: {
                    color: Theme.Widget.BackgroundColor,
                    border: {
                        size: Theme.Widget.Border.Size,
                        color: Theme.Widget.Border.Color,
                    }
                },
                text: { color: Theme.Widget.FontColor },
            }),
            lightBorderColor: config?.enabledStyle?.lightBorderColor,
            lightColor: config?.enabledStyle?.lightColor === undefined ? "#00FF00" : config?.enabledStyle?.lightColor,
            lightBlur: config?.enabledStyle?.lightBlur === undefined ? 15 : config?.enabledStyle?.lightBlur
        });
        this.#disabledStyle = new ToggleStyle({
            idle: TextBoxStyleWithFallback(config?.disabledStyle?.idle, {
                box: {
                    color: Theme.Widget.BackgroundColor,
                    border: {
                        size: Theme.Widget.Border.Size,
                        color: Theme.Widget.Border.Color,
                    }
                },
                text: { color: Theme.Widget.FontColor },
            }),
            lightBorderColor: config?.disabledStyle?.lightBorderColor,
            lightColor: config?.disabledStyle?.lightColor === undefined ? "#004400" : config?.enabledStyle?.lightColor,
        });

        this.Set(config?.value === undefined ? false : config?.value);
        this.#callback = config?.callback;
        if (this.#nodeProperty !== undefined) {
            this.#node.addPropertyChangeListener(this.#nodeProperty, (oldVal, newVal) => {
                this.Set(newVal);
            });
        }
    }

    Size(): Vector2 {
        return { "x": width, "y": height }
    }

    Draw(ctx: CanvasRenderingContext2D, position: Vector2, scale: number, mousePosition: Vector2 | undefined): Box {
        let style = this.#value ? this.#enabledStyle : this.#disabledStyle;
        return style.Draw(ctx, position, scale, this.#text, mousePosition);
    }

    Toggle(): void {
        this.Set(!this.#value);
    }

    Set(value: boolean): void {
        if (this.#value === value) {
            return;
        }
        this.#value = value;

        if (this.#nodeProperty !== undefined) {
            this.#node.setProperty(this.#nodeProperty, this.#value);
        }

        if (this.#callback !== undefined) {
            this.#callback(this.#value);
        }
    }

    ClickStart(): void {
        this.Toggle();
    }

    ClickEnd(): void {
    }
}

================
File: src/widgets/widget.ts
================
import { Box } from '../types/box';
import { Vector2 } from '../types/vector2';

export const width = 150;
export const height = 25;

export interface Widget {
    Size(): Vector2
    Draw(ctx: CanvasRenderingContext2D, position: Vector2, scale: number, mousePosition: Vector2 | undefined): Box
    ClickStart(): void
    ClickEnd(): void
}

================
File: src/camera.ts
================
import { Vector2, Zero } from "./types/vector2";

export class Camera {

    zoom: number;

    position: Vector2;

    constructor() {
        this.zoom = 1;
        this.position = Zero();
    }

    screenSpaceToGraphSpace(screenPosition: Vector2, out: Vector2): void {
        const scale = this.zoom;
        out.x = (screenPosition.x / scale) - (this.position.x / scale);
        out.y = (screenPosition.y / scale) - (this.position.y / scale);
    }

    graphSpaceToScreenSpace(graphPosition: Vector2, out: Vector2): void {
        out.x = this.position.x + (graphPosition.x * this.zoom);
        out.y = this.position.y + (graphPosition.y * this.zoom);
    }

    reset(): void {
        this.zoom = 1;
        this.position.x = 0;
        this.position.y = 0;
    }
}

================
File: src/connection.ts
================
import { FlowNode } from "./node";
import { Port } from "./port";
import { BoxCenter, InBox } from "./types/box";
import { Vector2, Zero } from "./types/vector2";

export interface ConnectionRendererParams {
    ctx: CanvasRenderingContext2D;
    start: Vector2;
    end: Vector2;
    graphScale: number;
    mouseOver: boolean;

    inNode: FlowNode | null;
    inPort: Port | null;
    outNode: FlowNode | null;
    outPort: Port | null;
}

export type ConnectionRenderer = (params: ConnectionRendererParams) => void

export function DefaultConnectionRenderer(connectionSize: number, connectionColor: string | undefined, mouseOverSize: number, mouseOverColor: string | undefined): ConnectionRenderer {
    return (params: ConnectionRendererParams) => {

        let color = "#00FF00";
        if (params.outPort !== null) {
            color = params.outPort.filledStyleColor()
        } else if (params.inPort !== null) {
            color = params.inPort.filledStyleColor()
        }

        let lineSize = connectionSize * params.graphScale;
        if (connectionColor !== undefined) {
            color = connectionColor;
        }

        if (params.mouseOver  || params.inNode?.selected() || params.outNode?.selected()) {
            lineSize = mouseOverSize * params.graphScale;
            params.ctx.shadowBlur = 25 * params.graphScale;

            if (mouseOverColor !== undefined) {
                color = mouseOverColor;
            }

            params.ctx.shadowColor = color;
        }

        params.ctx.strokeStyle = color;
        params.ctx.lineWidth = lineSize;

        // Draw
        params.ctx.beginPath();
        params.ctx.moveTo(params.start.x, params.start.y);
        const midX = (params.start.x + params.end.x) / 2;
        params.ctx.bezierCurveTo(midX, params.start.y, midX, params.end.y, params.end.x, params.end.y);
        params.ctx.stroke();
        params.ctx.shadowBlur = 0;
    }
}

export class Connection {

    // Variables for holding temp data, preventing object allocations each
    // frame
    #inPos: Vector2;
    #outPos: Vector2;

    #inNode: FlowNode | null;
    #inNodePortIndex: number;
    #outNode: FlowNode | null;
    #outNodePortIndex: number;
    #renderer: ConnectionRenderer;

    constructor(
        inNode: FlowNode | null,
        inNodePortIndex: number,
        outNode: FlowNode | null,
        outNodePortIndex: number,
        renderer: ConnectionRenderer,
    ) {

        this.#inNode = inNode;
        this.#inNodePortIndex = inNodePortIndex;
        this.#outNode = outNode;
        this.#outNodePortIndex = outNodePortIndex;
        this.#renderer = renderer;
        
        this.#inPos = Zero();
        this.#outPos = Zero();

        if (inNode !== null) {
            inNode.inputPort(this.#inNodePortIndex).addConnection(this);
        }

        if (outNode !== null) {
            outNode.outputPort(this.#outNodePortIndex).addConnection(this);
        }
    }

    render(ctx: CanvasRenderingContext2D, graphScale: number, mouseOver: boolean, mousePosition: Vector2 | undefined): void {

        // Not sure what to do here? Maybe we should throw an error in the 
        // future?
        if (this.#inNode === null && this.#outNode === null) {
            return;
        }

        if (this.#inNode !== null) {
            const inPortBox = this.#inNode.inputPortPosition(this.#inNodePortIndex)
            if (inPortBox === undefined) {
                return;
            }
            BoxCenter(inPortBox, this.#inPos);
        } else if (mousePosition !== undefined) {
            this.#inPos.x = mousePosition.x;
            this.#inPos.y = mousePosition.y;
        } else {
            return;
        }

        if (this.#outNode !== null) {
            const outPortBox = this.#outNode.outputPortPosition(this.#outNodePortIndex);
            if (outPortBox === undefined) {
                return;
            }
            BoxCenter(outPortBox, this.#outPos);
        } else if (mousePosition !== undefined) {
            this.#outPos.x = mousePosition.x;
            this.#outPos.y = mousePosition.y;
        } else {
            return;
        }

        this.#renderer({
            ctx: ctx,
            start: this.#inPos,
            end: this.#outPos,
            graphScale: graphScale,
            mouseOver: mouseOver,

            inPort: this.inPort(),
            inNode: this.#inNode,
            outPort: this.outPort(),
            outNode: this.#outNode,
        });
    }

    inNode(): FlowNode | null {
        return this.#inNode;
    }

    outNode(): FlowNode | null {
        return this.#outNode;
    }

    clearPort(mousePosition: Vector2): void {
        if (this.#inNode !== null) {
            const inPortBox = this.#inNode.inputPortPosition(this.#inNodePortIndex)
            if (inPortBox !== undefined && InBox(inPortBox, mousePosition)) {
                this.clearInput();
            }
        }

        if (this.#outNode !== null) {
            const outPortBox = this.#outNode.outputPortPosition(this.#outNodePortIndex);
            if (outPortBox !== undefined && InBox(outPortBox, mousePosition)) {
                this.clearOutput();
            }
        }
    }

    clearPorts(): void {
        this.clearInput();
        this.clearOutput();
    }

    setInput(node: FlowNode, portIndex: number, replace?: boolean): void {
        this.#inNode = node;
        this.#inNodePortIndex = portIndex;

        const port = this.#inNode.inputPort(portIndex);
        if(!!replace && port.connections().length > 0) {
            port.replaceConnection(this, 0);
        } else {
            port.addConnection(this);
        }
    }

    setOutput(node: FlowNode, portIndex: number): void {
        this.#outNode = node;
        this.#outNodePortIndex = portIndex;
        this.#outNode.outputPort(portIndex).addConnection(this);
    }

    clearInput() {
        this.#inNode?.inputPort(this.#inNodePortIndex).clearConnection(this);
        this.#inNode = null;
        this.#inNodePortIndex = -1;
    }

    clearOutput() {
        this.#outNode?.outputPort(this.#outNodePortIndex).clearConnection(this);
        this.#outNode = null;
        this.#outNodePortIndex = -1;
    }

    mouseOverPort(mousePosition: Vector2): Port | null {
        if (this.#inNode !== null) {
            const inPortBox = this.#inNode.inputPortPosition(this.#inNodePortIndex)
            if (inPortBox !== undefined && InBox(inPortBox, mousePosition)) {
                return this.#inNode.inputPort(this.#inNodePortIndex)
            }
        }

        if (this.#outNode !== null) {
            const outPortBox = this.#outNode.outputPortPosition(this.#outNodePortIndex);
            if (outPortBox !== undefined && InBox(outPortBox, mousePosition)) {
                return this.#outNode.outputPort(this.#outNodePortIndex)
            }
        }

        return null;
    }

    outPort(): Port | null {
        if (this.#outNode === null) {
            return null;
        }
        return this.#outNode.outputPort(this.#outNodePortIndex);
    }

    inPort(): Port | null {
        if (this.#inNode === null) {
            return null;
        }
        return this.#inNode.inputPort(this.#inNodePortIndex);
    }

    referencesNode(node: FlowNode): boolean {
        if (this.#inNode === node) {
            return true;
        }

        if (this.#outNode === node) {
            return true;
        }

        return false;
    }
}

================
File: src/contextMenu.ts
================
import { Theme } from './theme';
import { TextAlign } from './styles/canvasTextAlign';
import { TextStyle, TextStyleConfig, TextStyleFallback } from './styles/text';
import { Box, InBox } from './types/box';
import { List } from './types/list';
import { CopyVector2, Vector2, Zero } from './types/vector2';

const contextEntryHeight = 30;
const contextEntryWidth = 250;

export interface ContextMenuItemConfig {
    name?: string;
    textStyle?: TextStyleConfig;
    group?: string;

    callback?: () => void;
}

export interface ContextMenuConfig {
    name?: string;
    textStyle?: TextStyleConfig;
    group?: string;

    subMenus?: Array<ContextMenuConfig>;
    items?: Array<ContextMenuItemConfig>;
}


export class ContextMenuItem {
    #name: string;

    #callback?: () => void;

    #textStyle: TextStyle;

    public group?: string;

    constructor(config?: ContextMenuItemConfig) {
        this.#name = config?.name === undefined ? "item" : config.name;
        this.#callback = config?.callback;
        this.#textStyle = new TextStyle(config?.textStyle);
        this.group = config?.group;
    }

    getName(): string {
        return this.#name;
    }

    execute(): void {
        if (this.#callback === undefined) {
            return;
        }
        this.#callback();
    }
}

class ContextGroup {

    #calculatedHeight: number;

    constructor(public entries: Array<ContextEntry>) {
        this.#calculatedHeight = entries.length * contextEntryHeight
    }

    height() {
        return this.#calculatedHeight;
    }

}

export class ContextEntry {
    constructor(public text: string, public subMenu: ContextMenu | undefined, public item: ContextMenuItem | undefined) {
    }

    click(): void {
        this.item?.execute();
    }
}

export function CombineContextMenus(...contextMenus: Array<ContextMenuConfig | undefined>): ContextMenuConfig {
    const finalConfig: ContextMenuConfig = {
        items: new Array<ContextMenuItemConfig>,
        subMenus: new Array<ContextMenuConfig>,
    }

    for (let i = 0; i < contextMenus.length; i++) {
        const config = contextMenus[i];
        if (config === undefined) {
            continue;
        }

        if (config.items !== undefined) {
            finalConfig.items = finalConfig.items?.concat(config.items);
        }

        if (config.subMenus !== undefined) {
            finalConfig.subMenus = finalConfig.subMenus?.concat(config.subMenus);
        }
    }

    return finalConfig;
}

export class ContextMenu {

    #name: string;

    #items: Array<ContextMenuItem>;

    #subMenus: Array<ContextMenu>;

    #textStyle: TextStyle;

    #groups: List<ContextGroup>;

    #group?: string;

    #submenuPosition: Vector2;

    constructor(config?: ContextMenuConfig) {
        this.#submenuPosition = Zero();
        this.#groups = new List<ContextGroup>();
        this.#name = config?.name === undefined ? "menu" : config?.name;
        this.#items = new Array<ContextMenuItem>();
        this.#subMenus = new Array<ContextMenu>();
        this.#textStyle = new TextStyle(TextStyleFallback(config?.textStyle, {
            color: Theme.ContextMenu.FontColor
        }));
        this.#group = config?.group;

        if (config?.subMenus !== undefined) {
            for (let i = 0; i < config?.subMenus.length; i++) {
                this.#subMenus.push(new ContextMenu(config?.subMenus[i]));
            }
        }

        if (config?.items !== undefined) {
            for (let i = 0; i < config?.items.length; i++) {
                this.#items.push(new ContextMenuItem(config?.items[i]));
            }
        }

        this.#calculateEntries();
    }

    #calculateEntries(): void {

        const groupLUT = new Map<string, number>();
        const workingGroups = new Array<Array<ContextEntry>>();

        // Initialize first group for undefined entries
        workingGroups.push(new Array<ContextEntry>());

        for (let i = 0; i < this.#items.length; i++) {
            let group = 0; // index to undefined entries

            // Find collection that this entry belongs too
            const sub = this.#items[i]
            if (sub.group !== undefined) {
                const groupIndex = groupLUT.get(sub.group)
                if (groupIndex !== undefined) {
                    group = groupIndex
                } else {
                    group = workingGroups.length
                    groupLUT.set(sub.group, group)
                    workingGroups.push(new Array<ContextEntry>());
                }
            }

            workingGroups[group].push(new ContextEntry(
                this.#items[i].getName(),
                undefined,
                this.#items[i]
            ));
        }

        for (let i = 0; i < this.#subMenus.length; i++) {
            let group = 0; // index to undefined entries

            // Find collection that this entry belongs too
            const sub = this.#subMenus[i]
            if (sub.#group !== undefined) {
                const groupIndex = groupLUT.get(sub.#group)
                if (groupIndex !== undefined) {
                    group = groupIndex
                } else {
                    group = workingGroups.length
                    groupLUT.set(sub.#group, group)
                    workingGroups.push(new Array<ContextEntry>());
                }
            }

            workingGroups[group].push(new ContextEntry(
                this.#subMenus[i].getName(),
                this.#subMenus[i],
                undefined
            ));
        }

        this.#groups.Clear();
        for (let i = 0; i < workingGroups.length; i++) {
            const groupContent = workingGroups[i];
            if (groupContent.length === 0) {
                continue;
            }
            this.#groups.Push(new ContextGroup(groupContent));
        }
    }

    #calculatedWidth: number = 0;

    #getMaxWidthForText(ctx: CanvasRenderingContext2D, scale: number): number {
        if (this.#calculatedWidth > 0) {
            return this.#calculatedWidth;
        }

        const tempVec = Zero();
        for (let groupIndex = 0; groupIndex < this.#groups.Count(); groupIndex++) {
            const group = this.#groups.At(groupIndex);
            for (let entryIndex = 0; entryIndex < group.entries.length; entryIndex++) {
                this.#textStyle.measure(ctx, scale, group.entries[entryIndex].text, tempVec);
                this.#calculatedWidth = Math.max(tempVec.x, this.#calculatedWidth);
            }
        }
        return this.#calculatedWidth;
    }

    getName(): string {
        return this.#name;
    }

    #tempBox: Box = { Position: Zero(), Size: Zero() };

    #openSubMenu: ContextMenu | undefined;


    public render(ctx: CanvasRenderingContext2D, pppp: Vector2, graphScale: number, mousePosition: Vector2 | undefined, openRight: boolean): ContextEntry | null {
        const menuScale = 1.25;
        const scaledEntryHeight = menuScale * contextEntryHeight;
        const scaledEntryWidth = (menuScale * 40) + (this.#getMaxWidthForText(ctx, menuScale)); // contextEntryWidth;

        let totalScaledHeight = 0
        for (let i = 0; i < this.#groups.Count(); i++) {
            totalScaledHeight += this.#groups.At(i).height();
        }
        totalScaledHeight *= menuScale;

        const position = { x: 0, y: 0 };
        CopyVector2(position, pppp)

        if (!openRight) {
            position.x -= scaledEntryWidth;
        }

        // Clamp the position so it's not spilling off the canvas
        if (position.y + totalScaledHeight > ctx.canvas.clientHeight) {
            position.y = ctx.canvas.clientHeight - totalScaledHeight;
        }

        let submenuOpenRight = openRight;
        if (openRight && position.x + scaledEntryWidth > ctx.canvas.clientWidth) {
            position.x = ctx.canvas.clientWidth - scaledEntryWidth;
            submenuOpenRight = !submenuOpenRight;
        }

        this.#tempBox.Size.x = scaledEntryWidth;
        this.#tempBox.Size.y = scaledEntryHeight;
        CopyVector2(this.#tempBox.Position, position)



        ctx.textAlign = TextAlign.Left;
        ctx.fillStyle = Theme.ContextMenu.BackgroundColor;
        ctx.shadowColor = "#000000";
        ctx.shadowBlur = 5 * menuScale;
        ctx.beginPath();
        ctx.roundRect(
            position.x,
            this.#tempBox.Position.y,
            scaledEntryWidth,
            totalScaledHeight,
            5 * menuScale
        );
        ctx.fill();
        ctx.shadowBlur = 0;

        let mouseIsOver: ContextEntry | null = null;
        let subOpenedThisFrame = false;

        let optionsRendered = 0;
        for (let groupIndex = 0; groupIndex < this.#groups.Count(); groupIndex++) {
            const group = this.#groups.At(groupIndex);
            for (let entryIndex = 0; entryIndex < group.entries.length; entryIndex++) {
                const entry = group.entries[entryIndex];

                this.#tempBox.Position.y = position.y + (scaledEntryHeight * optionsRendered);

                let entryMousedOver = false;
                if (mousePosition !== undefined && InBox(this.#tempBox, mousePosition)) {
                    mouseIsOver = entry;
                    entryMousedOver = true
                    if (entry.subMenu !== undefined) {
                        this.#openSubMenu = entry.subMenu;
                        this.#submenuPosition.x = position.x
                        this.#submenuPosition.y = this.#tempBox.Position.y;
                        if (submenuOpenRight) {
                            this.#submenuPosition.x += scaledEntryWidth
                        }
                        subOpenedThisFrame = true;
                    } else {
                        this.#openSubMenu = undefined;
                    }
                }

                if (entryMousedOver || (this.#openSubMenu !== undefined && entry.subMenu === this.#openSubMenu)) {
                    ctx.fillStyle = Theme.ContextMenu.HighlightColor;
                    ctx.beginPath();
                    ctx.roundRect(
                        position.x + (scaledEntryHeight / 10),
                        this.#tempBox.Position.y + (scaledEntryHeight / 10),
                        scaledEntryWidth - (scaledEntryHeight / 5),
                        scaledEntryHeight - (scaledEntryHeight / 5),
                        5 * menuScale
                    );
                    ctx.fill();
                }

                this.#textStyle.setupStyle(ctx, menuScale);
                ctx.fillText(entry.text, position.x + (scaledEntryHeight / 5), this.#tempBox.Position.y + (scaledEntryHeight / 2))

                // Render arrows
                if (entry.subMenu !== undefined) {
                    ctx.beginPath()
                    ctx.strokeStyle = Theme.ContextMenu.FontColor;
                    ctx.lineWidth = 1 * menuScale;
                    ctx.lineTo(position.x + scaledEntryWidth - (scaledEntryHeight / 2.5), this.#tempBox.Position.y + (scaledEntryHeight / 3))
                    ctx.lineTo(position.x + scaledEntryWidth - (scaledEntryHeight / 4), this.#tempBox.Position.y + (scaledEntryHeight / 2))
                    ctx.lineTo(position.x + scaledEntryWidth - (scaledEntryHeight / 2.5), this.#tempBox.Position.y + scaledEntryHeight - (scaledEntryHeight / 3))
                    ctx.stroke();
                }

                optionsRendered++;
            }

            // Draw a line seperating the groups
            if (groupIndex !== this.#groups.Count() - 1) {
                ctx.strokeStyle = Theme.ContextMenu.FontColor;
                ctx.lineWidth = .5 * menuScale;
                ctx.beginPath();
                const startX = position.x + (scaledEntryHeight / 10);
                const y = this.#tempBox.Position.y + scaledEntryHeight
                ctx.lineTo(startX, y);
                ctx.lineTo(startX + scaledEntryWidth - (scaledEntryHeight / 5), y);
                ctx.stroke();
            }
        }

        if (this.#openSubMenu !== undefined) {
            const mouseOverSub = this.#openSubMenu.render(ctx, this.#submenuPosition, menuScale, mousePosition, submenuOpenRight)
            if (mouseOverSub !== null) {
                mouseIsOver = mouseOverSub;
            }
        }

        return mouseIsOver;
    }
}

================
File: src/draggable.ts
================
import { Box } from "./types/box";
import { Vector2 } from "./types/vector2";

export interface Draggable {
    Components(): Array<DraggableComponent>;
}

export interface DraggableComponent {
    Bounds(): Box;
    ClickStart(mousePosition: Vector2): void;
    ClickEnd(): void;
    MouseMove(mousePosition: Vector2): void;
}

================
File: src/graph.ts
================
import { CombineContextMenus, ContextEntry, ContextMenu, ContextMenuConfig } from './contextMenu';
import { Theme } from "./theme";
import { MouseObserver } from "./input";
import { FlowNode } from "./node";
import { NodeCreatedCallback, NodeFactoryConfig } from "./nodes/factory";
import { TimeExecution } from "./performance";
import { CursorStyle } from "./styles/cursor";
import { CopyVector2, Vector2, Zero } from './types/vector2';
import { Clamp01 } from "./utils/math";
import { GraphSubsystem, RenderResults } from './graphSubsystem';
import { FlowNote } from "./notes/note";
import { NoteAddedCallback, NoteDragStartCallback, NoteDragStopCallback, NoteRemovedCallback, NoteSubsystem, NoteSubsystemConfig } from "./notes/subsystem";
import { ConnectionRendererConfiguration, NodeAddedCallback, NodeRemovedCallback, NodeSubsystem } from "./nodes/subsystem";
import { Connection } from './connection';
import { Publisher } from './nodes/publisher';
import { VectorPool } from './types/pool';
import { Camera } from './camera';
import { PassSubsystem } from './pass/subsystem';
import { QuickMenu } from './quickMenu';

export type GraphRenderer = (canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D, position: Vector2, scale: number) => void;

function BuildBackgroundRenderer(backgroundColor: string): GraphRenderer {
    return (canvas: HTMLCanvasElement, context: CanvasRenderingContext2D, position: Vector2, scale: number) => {
        context.fillStyle = backgroundColor;
        context.fillRect(0, 0, canvas.width, canvas.height);

        const alpha = Math.round(Clamp01(scale - 0.3) * 255)
        if (alpha <= 0) {
            return;
        }

        context.fillStyle = `rgba(41, 54, 57, ${alpha})`;
        const spacing = 100;
        const pi2 = 2 * Math.PI
        const dotScale = 2 * scale;
        for (let x = -50; x < 50; x++) {
            const xPos = (x * spacing * scale) + position.x;
            for (let y = -50; y < 50; y++) {
                const yPos = (y * spacing * scale) + position.y;
                context.beginPath();
                context.arc(xPos, yPos, dotScale, 0, pi2);
                context.fill();
            }
        }
    }
}

const contextMenuGroup = "graph-context-menu";

export interface FlowNodeGraphConfiguration {
    backgroundRenderer?: GraphRenderer;
    backgroundColor?: string;
    idleConnection?: ConnectionRendererConfiguration
    contextMenu?: ContextMenuConfig
    nodes?: NodeFactoryConfig
    board?: NoteSubsystemConfig
}

interface OpenContextMenu {
    Menu: ContextMenu
    Position: Vector2
}

interface OpenQuickMenu {
    Menu: QuickMenu
    Position: Vector2
}

class GraphView {

    #subsystems: Array<GraphSubsystem>;

    constructor(subsystems: Array<GraphSubsystem>) {
        this.#subsystems = subsystems;
    }

    clickStart(mousePosition: Vector2, camera: Camera, ctrlKey: boolean) {
        // Since the graph is rendered from 0 => n, n is the last thing 
        // rendererd and is always shown to the user. So if their clicking on
        // two things technically, we need to make sure it's whatever was most 
        // recently rendered. So we traverse n => 0. 
        for (let i = this.#subsystems.length - 1; i >= 0; i--) {
            // If the user sucesfully clicked on something in this layer, don't
            // check any more layers.
            if (this.#subsystems[i].clickStart(mousePosition, camera, ctrlKey)) {
                return;
            }
        }
    }

    fileDrop(file: File): boolean {
        for (let i = this.#subsystems.length - 1; i >= 0; i--) {
            if (this.#subsystems[i].fileDrop(file)) {
                return true;
            }
        }
        return false;
    }

    openContextMenu(ctx: CanvasRenderingContext2D, position: Vector2): ContextMenuConfig {
        let finalConfig: ContextMenuConfig = {};

        for (let i = 0; i < this.#subsystems.length; i++) {
            const subSystemMenu = this.#subsystems[i].openContextMenu(ctx, position);
            if (subSystemMenu !== null) {
                finalConfig = CombineContextMenus(finalConfig, subSystemMenu);
            }
        }

        return finalConfig;
    }

    clickEnd(): void {
        for (let i = 0; i < this.#subsystems.length; i++) {
            this.#subsystems[i].clickEnd();
        }
    }

    mouseDragEvent(delta: Vector2, scale: number): boolean {
        for (let i = 0; i < this.#subsystems.length; i++) {
            if (this.#subsystems[i].mouseDragEvent(delta, scale)) {
                return true;
            }
        }
        return false;
    }

    render(ctx: CanvasRenderingContext2D, camera: Camera, mousePosition: Vector2 | undefined): RenderResults {
        const results: RenderResults = {};
        for (let i = 0; i < this.#subsystems.length; i++) {
            TimeExecution("Render_Subsystem_" + i, () => {
                let results = this.#subsystems[i].render(ctx, camera, mousePosition);
                if (results?.cursorStyle) {
                    results.cursorStyle = results?.cursorStyle;
                }
            })
        }
        return results;
    }
}

export class NodeFlowGraph {

    #ctx: CanvasRenderingContext2D;

    #canvas: HTMLCanvasElement;

    #backgroundRenderer: GraphRenderer

    #contextMenuConfig: ContextMenuConfig;

    #mousePosition: Vector2 | undefined;

    #camera: Camera;

    #openedContextMenu: OpenContextMenu | null;

    #openQuickMenu: OpenQuickMenu | null;

    #contextMenuEntryHovering: ContextEntry | null;

    #views: Array<GraphView>;

    #currentView: number;

    #mainNodeSubsystem: NodeSubsystem;

    #mainNoteSubsystem: NoteSubsystem;

    constructor(canvas: HTMLCanvasElement, config?: FlowNodeGraphConfiguration) {
        const postProcessPass = new PassSubsystem();

        this.#mainNodeSubsystem = new NodeSubsystem(postProcessPass, {
            nodes: config?.nodes,
            idleConnection: config?.idleConnection
        });

        this.#lastFrameCursor = CursorStyle.Default;
        this.#cursor = CursorStyle.Default;

        this.#mainNoteSubsystem = new NoteSubsystem(config?.board);

        this.#views = [
            new GraphView([
                this.#mainNoteSubsystem,
                this.#mainNodeSubsystem,
                postProcessPass
            ])
        ];
        this.#currentView = 0;

        this.#camera = new Camera();

        this.#contextMenuConfig = CombineContextMenus({
            items: [
                {
                    name: "Reset View",
                    group: contextMenuGroup,
                    callback: this.#camera.reset.bind(this.#camera)
                },
            ],
        }, config?.contextMenu);

        this.#openedContextMenu = null;
        this.#openQuickMenu = null;
        this.#contextMenuEntryHovering = null;

        this.#canvas = canvas;
        const ctx = canvas.getContext("2d")
        if (ctx === null) {
            throw new Error("could not create canvas context")
        }
        this.#ctx = ctx;

        if (config?.backgroundRenderer !== undefined) {
            this.#backgroundRenderer = config?.backgroundRenderer
        } else {
            const backgroundColor = config?.backgroundColor === undefined ? Theme.Graph.BackgroundColor : config.backgroundColor;
            this.#backgroundRenderer = BuildBackgroundRenderer(backgroundColor);
        }

        window.requestAnimationFrame(this.#render.bind(this));

        this.#canvas.addEventListener('wheel', (event) => {
            event.preventDefault();
            this.zoom(Math.sign(event.deltaY));
        }, false);

        new MouseObserver(this.#canvas,
            this.#mouseDragEvent.bind(this),

            // Mouse move event
            (mousePosition) => {
                this.#mousePosition = mousePosition;
            },

            this.#clickStart.bind(this),
            this.#clickEnd.bind(this),
            this.#openContextMenu.bind(this),
            this.#fileDrop.bind(this)
        );

        document.addEventListener(
            "keydown",
            (e) => {
                if (document.activeElement) {
                    if (["INPUT", "TEXTAREA"].includes(document.activeElement.tagName)) return;
                }

                if (this.#openQuickMenu) {
                    if (e.code === "Escape") {
                        this.#openQuickMenu = null;
                        return;
                    }

                    if (e.code === "Enter") {
                        this.#openQuickMenu.Menu.execute();
                        this.#openQuickMenu = null;
                        return;
                    }

                    this.#openQuickMenu.Menu.keyboardEvent(e);
                    return
                }

                const spacePressed = e.key == " " || e.code == "Space";
                if (!spacePressed) {
                    return;
                }

                if (!this.#mousePosition) {
                    return;
                }
                const contextMenuPosition = this.#sceenPositionToGraphPosition(this.#mousePosition);

                let items = this.#mainNodeSubsystem.nodeFactory().newNodeSubmenus(this.#mainNodeSubsystem, contextMenuPosition);
                this.#openQuickMenu = {
                    Menu: new QuickMenu({
                        subMenus: items,
                    }),
                    Position: contextMenuPosition
                }
            }
        );
    }

    #fileDrop(file: File): void {

        if (this.currentView().fileDrop(file)) {
            return;
        }

        const contents = file.name.split('.');
        const extension = contents[contents.length - 1];
        if (extension !== "jpg" && extension !== "jpeg" && extension !== "png") {
            return;
        }

        let pos = Zero();
        if (this.#mousePosition) {
            CopyVector2(pos, this.#sceenPositionToGraphPosition(this.#mousePosition));
        }

        this.#mainNodeSubsystem.addNode(new FlowNode({
            title: contents[0],
            position: pos,
            widgets: [{
                type: "image",
                config: {
                    blob: file,
                }
            }]
        }));
    }

    public addNoteAddedListener(callback: NoteAddedCallback): void {
        this.#mainNoteSubsystem.addNoteAddedListener(callback);
    }

    public addNoteRemovedListener(callback: NoteRemovedCallback): void {
        this.#mainNoteSubsystem.addNoteRemovedListener(callback);
    }

    public addNoteDragStartListener(callback: NoteDragStartCallback): void {
        this.#mainNoteSubsystem.addNoteDragStartListener(callback);
    }

    public addNoteDragStopListener(callback: NoteDragStopCallback): void {
        this.#mainNoteSubsystem.addNoteDragStopListener(callback);
    }


    zoom(amount: number): void {

        let oldPos: Vector2 | undefined = undefined;
        if (this.#mousePosition) {
            oldPos = this.#sceenPositionToGraphPosition(this.#mousePosition);;
        }

        this.#camera.zoom += amount * this.#camera.zoom * 0.05;

        if (!oldPos || !this.#mousePosition) {
            return;
        }
        // Attempt zoom around where the current mouse is.
        const newPos = this.#sceenPositionToGraphPosition(this.#mousePosition);
        this.#camera.position.x += (newPos.x - oldPos.x) * this.#camera.zoom;
        this.#camera.position.y += (newPos.y - oldPos.y) * this.#camera.zoom;
    }

    #clickStart(mousePosition: Vector2, ctrlKey: boolean): void {
        if (this.#contextMenuEntryHovering !== null) {
            this.#contextMenuEntryHovering.click();
            this.#openedContextMenu = null;
            this.#contextMenuEntryHovering = null;
            return;
        }
        this.#openedContextMenu = null;
        this.#openQuickMenu = null;
        this.#contextMenuEntryHovering = null;

        this.#mousePosition = mousePosition;
        this.currentView().clickStart(mousePosition, this.#camera, ctrlKey);
    }

    currentView(): GraphView {
        return this.#views[this.#currentView];
    }

    organize(): void {
        this.#mainNodeSubsystem.organize(this.#ctx);
    }

    addPublisher(identifier: string, publisher: Publisher): void {
        this.#mainNodeSubsystem.addPublisher(identifier, publisher);
    }

    getNodes(): Array<FlowNode> {
        return this.#mainNodeSubsystem.getNodes();
    }

    connectedInputsNodeReferences(nodeIndex: number): Array<FlowNode> {
        return this.#mainNodeSubsystem.connectedInputsNodeReferencesByIndex(nodeIndex);
    }

    connectedOutputsNodeReferences(nodeIndex: number): Array<FlowNode> {
        return this.#mainNodeSubsystem.connectedOutputsNodeReferences(nodeIndex);
    }

    connectNodes(nodeOut: FlowNode, outPort: number, nodeIn: FlowNode, inPort: number): Connection | undefined {
        return this.#mainNodeSubsystem.connectNodes(nodeOut, outPort, nodeIn, inPort);
    }

    addNode(node: FlowNode): void {
        this.#mainNodeSubsystem.addNode(node);
    }

    addNote(note: FlowNote): void {
        this.#mainNoteSubsystem.addNote(note);
    }

    public addOnNodeCreatedListener(callback: NodeCreatedCallback): void {
        this.#mainNodeSubsystem.addOnNodeCreatedListener(callback);
    }

    public addOnNodeAddedListener(callback: NodeAddedCallback): void {
        this.#mainNodeSubsystem.addOnNodeAddedListener(callback);
    }

    public addOnNodeRemovedListener(callback: NodeRemovedCallback): void {
        this.#mainNodeSubsystem.addOnNodeRemovedListener(callback);
    }

    #sceenPositionToGraphPosition(screenPosition: Vector2): Vector2 {
        const out = Zero();
        this.#camera.screenSpaceToGraphSpace(screenPosition, out);
        return out;
    }

    #openContextMenu(position: Vector2): void {
        let finalConfig = this.#contextMenuConfig;

        const contextMenuPosition = this.#sceenPositionToGraphPosition(position);

        finalConfig = CombineContextMenus(finalConfig, this.currentView().openContextMenu(this.#ctx, contextMenuPosition));

        this.#openedContextMenu = {
            Menu: new ContextMenu(finalConfig),
            Position: contextMenuPosition,
        };
    }


    // Somethings wrong here. Needs more testing
    // #fitView(): void {
    //     if (this.#nodes.length === 0) {
    //         return;
    //     }

    //     const curBox: Box = {
    //         Position: { x: 0, y: 0 },
    //         Size: { x: 0, y: 0 }
    //     };
    //     CopyBox(curBox, this.#nodes[0].calculateBounds(this.#ctx, this.#graphState.position, this.#graphState.scale));

    //     for (let i = 1; i < this.#nodes.length; i++) {
    //         ExpandBox(curBox, this.#nodes[i].calculateBounds(this.#ctx, this.#graphState.position, this.#graphState.scale));
    //     }

    //     CopyVector2(this.#graphState.position, curBox.Position);
    // }

    #clickEnd(): void {
        this.currentView().clickEnd();
    }

    #mouseDragEvent(delta: Vector2): void {
        let draggingSomething = this.currentView().mouseDragEvent(delta, this.#camera.zoom);
        if (!draggingSomething) {
            this.#camera.position.x += delta.x;
            this.#camera.position.y += delta.y;
        }
    }

    #lastFrameCursor: CursorStyle;

    #cursor: CursorStyle;

    #render(): void {
        if (this.#canvas.parentNode !== null) {
            // Stupid as any because typescript doesn't think it exists
            var rect = (this.#canvas.parentNode as any).getBoundingClientRect();
            this.#canvas.width = rect.width;
            this.#canvas.height = rect.height;
        }


        this.#cursor = CursorStyle.Default;

        TimeExecution("Render_Background", this.#renderBackground.bind(this));

        TimeExecution("Render_View_" + this.#currentView, () => {
            let results = this.currentView().render(this.#ctx, this.#camera, this.#mousePosition);
            if (results?.cursorStyle) {
                this.#cursor = results?.cursorStyle;
            }
        });

        TimeExecution("Render_Context", this.#renderContextMenu.bind(this));

        TimeExecution("Render_QuickMenu", this.#renderQuickMenu.bind(this))

        // Only update CSS style if things have changed
        // TODO: Does this actually have any measurable performance savings?
        if (this.#lastFrameCursor !== this.#cursor) {
            this.#canvas.style.cursor = this.#cursor;
        }
        this.#lastFrameCursor = this.#cursor;

        window.requestAnimationFrame(this.#render.bind(this));
    }

    #renderBackground(): void {
        this.#backgroundRenderer(this.#canvas, this.#ctx, this.#camera.position, this.#camera.zoom);
    }

    #renderContextMenu(): void {
        VectorPool.run(() => {
            if (this.#openedContextMenu !== null) {
                const pos = VectorPool.get();
                this.#camera.graphSpaceToScreenSpace(this.#openedContextMenu.Position, pos)
                this.#contextMenuEntryHovering = this.#openedContextMenu.Menu.render(this.#ctx, pos, this.#camera.zoom, this.#mousePosition, true);

                if (this.#contextMenuEntryHovering !== null) {
                    this.#cursor = CursorStyle.Pointer;
                }
            }
        });
    }

    #renderQuickMenu(): void {
        VectorPool.run(() => {
            if (this.#openQuickMenu !== null) {
                const pos = VectorPool.get();
                this.#camera.graphSpaceToScreenSpace(this.#openQuickMenu.Position, pos)
                this.#contextMenuEntryHovering = this.#openQuickMenu.Menu.render(this.#ctx, pos, this.#camera.zoom, this.#mousePosition);

                if (this.#contextMenuEntryHovering !== null) {
                    this.#cursor = CursorStyle.Pointer;
                }
            }
        });
    }
}

================
File: src/graphSubsystem.ts
================
import { Camera } from "./camera";
import { ContextMenuConfig } from "./contextMenu";
import { CursorStyle } from "./styles/cursor";
import { Vector2 } from "./types/vector2";

export interface RenderResults {
    cursorStyle?: CursorStyle;
}

export interface GraphSubsystem {

    render(ctx: CanvasRenderingContext2D, camera: Camera, mousePosition: Vector2 | undefined): RenderResults | undefined;

    openContextMenu(ctx: CanvasRenderingContext2D, position: Vector2): ContextMenuConfig | null;

    /**
     * Event for when the graph is clicked. 
     * 
     * Returns whether or not the subsystem had one of it's elements clicked on
     * 
     * @param mousePosition Where the mouse is on the graph
     * @param ctrlKey Whether or not the ctrl key is pressed
     */
    clickStart(mousePosition: Vector2, camera: Camera, ctrlKey: boolean): boolean;

    mouseDragEvent(delta: Vector2, scale: number): boolean;

    fileDrop(file: File): boolean;

    clickEnd(): void;
}

================
File: src/index.ts
================
import { NodeFlowGraph } from './graph';
import { FlowNode, FlowNodeConfig } from './node';

export { NodeFlowGraph, FlowNode, FlowNodeConfig };

import { Theme } from './theme';
export { Theme };

import { Publisher, PublisherConfig } from './nodes/publisher';
export { Publisher, PublisherConfig };

import { FlowNote } from './notes/note';
export { FlowNote };

// Widgets
import { NumberWidget } from './widgets/number';
import { ColorWidget } from './widgets/color';
import { StringWidget } from './widgets/string';
import { ButtonWidget } from './widgets/button';
import { ToggleWidget } from './widgets/toggle';
import { SliderWidget } from './widgets/slider';
import { ImageWidget } from './widgets/image';
export {
    NumberWidget, ColorWidget, StringWidget, ButtonWidget, ToggleWidget, SliderWidget, ImageWidget
};

import { GlobalWidgetFactory } from './widgets/factory';
export { GlobalWidgetFactory };

================
File: src/input.ts
================
import { CopyVector2, SubVector2, Vector2, Zero } from "./types/vector2";

export class MouseObserver {

    #clicked: boolean;

    #lastTouch: Vector2;

    #ele: HTMLElement

    #lastMousePosition: Vector2;

    #dragCallback: (delta: Vector2) => void
    #moveCallback: (position: Vector2) => void
    #clickStart: (position: Vector2, shiftOrCtrl: boolean) => void
    #clickStop: () => void
    #contextMenu: (position: Vector2) => void

    constructor(
        ele: HTMLElement,
        dragCallback: (delta: Vector2) => void,
        moveCallback: (position: Vector2) => void,
        clickStart: (position: Vector2, shiftOrCtrl: boolean) => void,
        clickStop: () => void,
        contextMenu: (position: Vector2) => void,
        fileDrop: (file: File) => void
    ) {
        this.#ele = ele;
        this.#dragCallback = dragCallback;
        this.#moveCallback = moveCallback;
        this.#clickStart = clickStart;
        this.#clickStop = clickStop;
        this.#contextMenu = contextMenu;

        this.#clicked = false;
        this.#lastTouch = Zero();
        this.#lastMousePosition = Zero();

        // Down
        ele.addEventListener('mousedown', this.#down.bind(this), false);
        ele.addEventListener('touchstart', this.#touchDown.bind(this), false);

        // Up
        document.addEventListener('mouseup', this.#up.bind(this), false);
        document.addEventListener('touchend', this.#up.bind(this), false);

        // Move
        ele.addEventListener('mousemove', this.#move.bind(this), false);
        ele.addEventListener('touchmove', this.#moveTouch.bind(this), false);

        ele.addEventListener('drop', (ev) => {
            ev.preventDefault();
            console.log(ev)

            if (ev.dataTransfer?.items) {
                // Use DataTransferItemList interface to access the file(s)
                [...ev.dataTransfer.items].forEach((item, i) => {
                    // If dropped items aren't files, reject them
                    if (item.kind === "file") {
                        const file = item.getAsFile();
                        if (file) {
                            fileDrop(file);
                            console.log(file)
                            console.log(` file[${i}].name = ${file.name}`);
                        }
                    }
                });
            } else if (ev.dataTransfer) {
                // Use DataTransfer interface to access the file(s)
                [...ev.dataTransfer.files].forEach((file, i) => {
                    console.log(` file[${i}].name = ${file.name}`);
                });
            }
        });

        ele.addEventListener('dragover', (ev) => {
            ev.preventDefault();
            this.#moveCallback(this.#mousePosition(ev));
            // console.log(ev)
        });

        // Context
        ele.addEventListener('contextmenu', (evt) => {
            contextMenu(this.#mousePosition(evt));
            evt.preventDefault()
        }, false);
    }

    #mousePosition(event: MouseEvent | DragEvent): Vector2 {
        var rect = this.#ele.getBoundingClientRect();
        return {
            x: event.clientX - rect.left,
            y: event.clientY - rect.top
        }
    }

    #move(event: MouseEvent): void {
        const pos = this.#mousePosition(event);

        if (this.#clicked) {
            const delta = Zero();
            SubVector2(delta, pos, this.#lastMousePosition);
            this.#dragCallback(delta)
        }

        this.#moveCallback(pos);
        CopyVector2(this.#lastMousePosition, pos);
    }

    #moveTouch(event: TouchEvent): void {
        const rect = this.#ele.getBoundingClientRect();
        const pos = {
            x: event.touches[0].clientX - rect.left,
            y: event.touches[0].clientY - rect.top
        }
        this.#moveCallback(pos);

        if (this.#clicked) {
            this.#dragCallback({
                x: pos.x - this.#lastTouch.x,
                y: pos.y - this.#lastTouch.y,
            });
        }

        CopyVector2(this.#lastTouch, pos);
    }

    #down(event: MouseEvent): void {
        // Only register left clicks
        if (event.button !== 0) {
            return;
        }
        this.#clicked = true;
        this.#clickStart(this.#mousePosition(event), event.ctrlKey || event.shiftKey);
    }

    #touchDown(event: TouchEvent) {
        this.#clicked = true;
        const rect = this.#ele.getBoundingClientRect();
        this.#lastTouch.x = event.touches[0].clientX - rect.left;
        this.#lastTouch.y = event.touches[0].clientY - rect.top;
        this.#clickStart(this.#lastTouch, false);
    }

    #up(event: MouseEvent): void {
        // Only register left clicks
        if (event.button !== 0) {
            return;
        }
        this.#clicked = false
        this.#clickStop();
    }
}

================
File: src/metadata.ts
================
export interface Metadata {
    [name: string]: any;
}

================
File: src/node.ts
================
import { Port, PortConfig, PortType } from "./port";
import { FontWeight, TextStyle, TextStyleConfig, TextStyleFallback } from "./styles/text";
import { Box, InBox } from "./types/box";
import { CopyVector2, Distance, ScaleVector, Vector2, Zero } from "./types/vector2";
import { Widget } from './widgets/widget';
import { List } from './types/list';
import { BoxStyle, BoxStyleConfig, BoxStyleWithFallback } from "./styles/box";
import { Text } from "./types/text";
import { GlobalWidgetFactory } from "./widgets/factory";
import { Theme } from "./theme";
import { TextAlign } from "./styles/canvasTextAlign";
import { TextBaseline } from "./styles/canvasTextBaseline";
import { CombineContextMenus, ContextMenuConfig, ContextMenuItemConfig } from "./contextMenu";
import { nodeFlowGroup } from "./nodes/subsystem";
import { SetStringPopup } from "./popups/string";
import { ButtonWidget } from "./widgets/button";
import { FormPopup } from "./popups/form";
import { NumberWidget } from "./widgets/number";
import { StringWidget } from "./widgets/string";
import { ToggleWidget } from "./widgets/toggle";
import { ColorWidget } from "./widgets/color";
import { SliderWidget } from "./widgets/slider";
import { ImageWidget } from "./widgets/image";
import { VectorPool } from "./types/pool";
import { Camera } from "./camera";
import { PassSubsystem } from "./pass/subsystem";
import { splitString, splitStringIntoLines } from "./utils/string";
import { Metadata } from './metadata';

const MINIMUM_NODE_WIDTH = 150;

type AnyPropertyChangeCallback = (propertyName: string, oldValue: any, newValue: any) => void
type PropertyChangeCallback = (oldValue: any, newValue: any) => void
type TitleChangeCallback = (node: FlowNode, oldTitle: string, newTitle: string) => void
type InfoChangeCallback = (node: FlowNode, oldInfo: string, newInfo: string) => void



export interface WidgetConfig {
    type?: string,
    config?: any
}

export interface FlowNodeTitleConfig {
    textStyle?: TextStyleConfig;
    color?: string;
    padding?: number;
}

export interface FlowNodeStyle {
    title?: FlowNodeTitleConfig;
    idle?: BoxStyleConfig;
    mouseOver?: BoxStyleConfig;
    grabbed?: BoxStyleConfig;
    selected?: BoxStyleConfig;
    portText?: TextStyleConfig;
}

export interface FlowNodeConfig {
    position?: Vector2;
    title?: string;
    subTitle?: string;
    info?: string;
    locked?: boolean;
    data?: Metadata;
    contextMenu?: ContextMenuConfig;
    metadata?: any;

    canEditTitle?: boolean;
    canEditInfo?: boolean;
    canEditPorts?: boolean;

    // Ports
    inputs?: Array<PortConfig>;
    outputs?: Array<PortConfig>;

    // Callbacks
    onGrab?: () => void;
    onRelease?: () => void;
    onSelect?: () => void;
    onUnselect?: () => void;
    onDragStop?: (FlowNode: FlowNode) => void;
    onFileDrop?: (file: File) => void;
    onTitleChange?: TitleChangeCallback;
    onInfoChange?: InfoChangeCallback;

    // Widgets
    widgets?: Array<WidgetConfig>;

    // Styling
    style?: FlowNodeStyle;
}

export enum NodeState {
    Idle,
    MouseOver,
    Grabbed
}

export interface NodeIntersection {
    Node?: FlowNode

    // Port
    Port?: Port
    PortIndex?: number
    PortIsInput?: boolean

    // Widget
    Widget?: Widget
    WidgetIndex?: number

}

export class FlowNode {

    #position: Vector2;

    #title: Text;

    #subTitle: Text;

    #infoSymbol: Text;

    #infoText: string;

    #input: Array<Port>;

    #output: Array<Port>;

    #widgets: Array<Widget>;

    #locked: boolean;

    #canEditTitle: boolean;

    #canEditInfo: boolean;

    #canEditPorts: boolean;

    #contextMenu: ContextMenuConfig | null;

    #metadata: any;

    // Callbacks

    #onSelect: Array<() => void>;

    #onUnselect: Array<() => void>;

    #onFiledrop: Array<(file: File) => void>;

    #onDragStop: Array<(node: FlowNode) => void>;

    #titleChangeCallback: Array<TitleChangeCallback>;

    #infoChangeCallback: Array<InfoChangeCallback>;

    // Styling ================================================================

    #titleColor: string;

    #selectedStyle: BoxStyle;

    #stateStyles: Map<NodeState, BoxStyle>;

    #padding: number;

    #portTextStyle: TextStyle;

    #elementSpacing: number;

    // Runtime ================================================================

    #selected: boolean;

    #inputPortPositions: List<Box>;

    #outputPortPositions: List<Box>;

    #widgetPositions: List<Box>;

    #data: Metadata;

    #registeredAnyPropertyChangeCallbacks: Array<AnyPropertyChangeCallback>;

    #registeredPropertyChangeCallbacks: Map<string, Array<PropertyChangeCallback>>;

    constructor(config?: FlowNodeConfig) {
        this.#input = new Array<Port>();
        this.#output = new Array<Port>();
        this.#widgets = new Array<Widget>();
        this.#inputPortPositions = new List<Box>();
        this.#outputPortPositions = new List<Box>();
        this.#widgetPositions = new List<Box>();
        this.#elementSpacing = 15;
        this.#locked = config?.locked === undefined ? false : config.locked;
        this.#data = config?.data === undefined ? {} : config?.data;
        this.#registeredPropertyChangeCallbacks = new Map<string, Array<PropertyChangeCallback>>();
        this.#registeredAnyPropertyChangeCallbacks = new Array<AnyPropertyChangeCallback>();
        this.#canEditPorts = config?.canEditPorts === undefined ? false : config.canEditPorts;
        this.#canEditTitle = config?.canEditTitle === undefined ? false : config.canEditTitle;
        this.#canEditInfo = config?.canEditInfo === undefined ? false : config.canEditInfo;
        this.#contextMenu = config?.contextMenu === undefined ? null : config.contextMenu;
        this.#metadata = config?.metadata;

        this.#selected = false;
        this.#onSelect = new Array<() => void>();
        this.#onUnselect = new Array<() => void>();
        this.#onFiledrop = new Array<(file: File) => void>();
        this.#onDragStop = new Array<() => void>();
        this.#titleChangeCallback = new Array<TitleChangeCallback>();
        this.#infoChangeCallback = new Array<InfoChangeCallback>();

        if (config?.onSelect) {
            this.#onSelect.push(config?.onSelect);
        }

        if (config?.onUnselect) {
            this.#onUnselect.push(config?.onUnselect);
        }

        if (config?.onFileDrop) {
            this.#onFiledrop.push(config?.onFileDrop);
        }

        if (config?.onDragStop) {
            this.#onDragStop.push(config.onDragStop);
        }

        if (config?.onTitleChange) {
            this.#titleChangeCallback.push(config.onTitleChange);
        }

        if (config?.onInfoChange) {
            this.#infoChangeCallback.push(config.onInfoChange);
        }

        this.#position = config?.position === undefined ? { x: 0, y: 0 } : config.position;
        this.#title = new Text(
            config?.title === undefined ? "" : config.title,
            TextStyleFallback(config?.style?.title?.textStyle, {
                size: 16,
                weight: FontWeight.Bold,
                color: Theme.Node.FontColor
            })
        );

        this.#subTitle = new Text(
            config?.subTitle === undefined ? "" : config.subTitle,
            TextStyleFallback(config?.style?.title?.textStyle, {
                size: 10,
                weight: FontWeight.Bold,
                color: Theme.Node.FontColor
            })
        );

        this.#infoSymbol = new Text(
            "i",
            {
                size: 13,
                weight: FontWeight.Bold,
                color: Theme.Node.FontColor
            }
        );
        this.#infoText = config?.info ? config?.info : "";

        this.#titleColor = config?.style?.title?.color === undefined ? "#154050" : config?.style?.title?.color;

        this.#padding = config?.style?.title?.padding === undefined ? 15 : config?.style?.title?.padding;

        this.#stateStyles = new Map<NodeState, BoxStyle>();
        this.#stateStyles.set(NodeState.Idle, new BoxStyle(BoxStyleWithFallback(config?.style?.idle, {
            border: { color: Theme.Node.Border.Idle, size: 1 },
            radius: Theme.Node.BorderRadius,
            color: Theme.Node.BackgroundColor,
        })));
        this.#stateStyles.set(NodeState.MouseOver, new BoxStyle(BoxStyleWithFallback(config?.style?.mouseOver, {
            border: { color: Theme.Node.Border.MouseOver, size: 1.1, },
            radius: Theme.Node.BorderRadius,
            color: Theme.Node.BackgroundColor,
        })));
        this.#stateStyles.set(NodeState.Grabbed, new BoxStyle(BoxStyleWithFallback(config?.style?.grabbed, {
            border: { color: Theme.Node.Border.Grabbed, size: 2, },
            radius: Theme.Node.BorderRadius,
            color: Theme.Node.BackgroundColor,
        })));

        this.#selectedStyle = new BoxStyle(BoxStyleWithFallback(config?.style?.selected, {
            border: { color: Theme.Node.Border.Selected, size: 1, },
            radius: Theme.Node.BorderRadius,
            color: Theme.Node.BackgroundColor,
        }));

        this.#portTextStyle = new TextStyle({
            size: config?.style?.portText?.size === undefined ? 14 : config?.style?.portText?.size,
            color: config?.style?.portText?.color === undefined ? Theme.Node.Port.FontColor : config?.style?.portText?.color,
            font: config?.style?.portText?.font,
            weight: config?.style?.portText?.weight,
        });

        if (config?.inputs !== undefined) {
            for (let i = 0; i < config.inputs.length; i++) {
                this.addInput(config.inputs[i]);
            }
        }

        if (config?.outputs !== undefined) {
            for (let i = 0; i < config.outputs.length; i++) {
                this.addOutput(config.outputs[i]);
            }
        }

        if (config?.widgets !== undefined) {
            for (let i = 0; i < config.widgets.length; i++) {
                const widget = config.widgets[i];
                if (widget.type === undefined) {
                    continue;
                }
                this.addWidget(GlobalWidgetFactory.create(this, widget.type, widget.config))
            }
        }
    }

    public metadata(): any {
        return this.#metadata;
    }

    public selected(): boolean {
        return this.#selected;
    }

    public select(): void {
        if (this.#selected) {
            return;
        }
        this.#selected = true;
        for (let i = 0; i < this.#onSelect.length; i++) {
            this.#onSelect[i]();
        }
    }

    public raiseDragStoppedEvent() {
        for (let i = 0; i < this.#onDragStop.length; i++) {
            this.#onDragStop[i](this);
        }
    }

    public addTitleChangeListener(callback: TitleChangeCallback): void {
        if (callback === undefined || callback === null) {
        }
        this.#titleChangeCallback.push(callback);
    }

    public addInfoChangeListener(callback: InfoChangeCallback): void {
        if (callback === undefined || callback === null) {
        }
        this.#infoChangeCallback.push(callback);
    }


    public addDragStoppedListener(callback: (node: FlowNode) => void): void {
        if (callback === undefined || callback === null) {
        }
        this.#onDragStop.push(callback);
    }

    public addAnyPropertyChangeListener(callback: AnyPropertyChangeCallback): void {
        if (callback === undefined || callback === null) {
        }
        this.#registeredAnyPropertyChangeCallbacks.push(callback);
    }

    public addPropertyChangeListener(name: string, callback: PropertyChangeCallback): void {
        if (!this.#registeredPropertyChangeCallbacks.has(name)) {
            this.#registeredPropertyChangeCallbacks.set(name, []);
        }

        const callbacks = this.#registeredPropertyChangeCallbacks.get(name);
        if (callbacks === undefined) {
            return;
        }
        callbacks.push(callback);
    }

    public setProperty(name: string, value: any): void {
        const oldValue = this.#data[name];
        if (oldValue === value) {
            return;
        }

        this.#data[name] = value;

        for (let i = 0; i < this.#registeredAnyPropertyChangeCallbacks.length; i++) {
            this.#registeredAnyPropertyChangeCallbacks[i](name, oldValue, value);
        }

        const callbacks = this.#registeredPropertyChangeCallbacks.get(name);
        if (callbacks === undefined) {
            return;
        }

        for (let i = 0; i < callbacks.length; i++) {
            callbacks[i](oldValue, value);
        }
    }

    public getProperty(name: string): any {
        return this.#data[name];
    }

    #popupNodeTitleSelection(): void {
        SetStringPopup({
            title: "Set Node Title",
            startingValue: this.title(),
            onUpdate: (value: string): void => {
                this.setTitle(value);
            },
        }).Show();
    }

    #popupNodeInfoSelection(): void {
        SetStringPopup({
            title: "Set Node Info",
            startingValue: this.#infoText,
            onUpdate: (value: string): void => {
                this.setInfo(value);
            },
        }).Show();
    }

    #popupNewButtonWidget(): void {
        SetStringPopup({
            title: "New Button Widget Text",
            startingValue: "My Button",
            onUpdate: (value: string): void => {
                this.addWidget(new ButtonWidget({
                    text: value
                }));
            },
        }).Show()
    }

    #widgetSubmenu(): ContextMenuConfig {
        return {
            name: "Widget",
            items: [
                {
                    name: "Button",
                    callback: this.#popupNewButtonWidget.bind(this),
                },
                {
                    name: "Number",
                    callback: () => {
                        this.addWidget(new NumberWidget(this))
                    }
                },
                {
                    name: "Color",
                    callback: () => {
                        this.addWidget(new ColorWidget(this))
                    }
                },
                {
                    name: "Slider",
                    callback: () => {
                        FormPopup({
                            title: "New Slider",
                            form: [
                                {
                                    name: "min",
                                    type: "number",
                                    startingValue: 0
                                },
                                {
                                    name: "max",
                                    type: "number",
                                    startingValue: 100
                                }
                            ],
                            onUpdate: (data: Array<any>) => {
                                this.addWidget(new SliderWidget(this, {
                                    min: data[0],
                                    max: data[1],
                                }));
                            }
                        }).Show();
                    }
                },
                {
                    name: "String",
                    callback: () => {
                        this.addWidget(new StringWidget(this))
                    }
                },
                {
                    name: "Toggle",
                    callback: () => {
                        this.addWidget(new ToggleWidget(this))
                    }
                },
                {
                    name: "Image",
                    callback: () => {
                        FormPopup({
                            title: "New Image",
                            form: [
                                {
                                    name: "URL",
                                    type: "text",
                                    startingValue: "https://pbs.twimg.com/media/GYabtu6bsAA7m99?format=jpg&name=medium"
                                },
                                {
                                    name: "Max Width",
                                    type: "number",
                                    startingValue: MINIMUM_NODE_WIDTH
                                },
                                {
                                    name: "Max Height",
                                    type: "number",
                                    startingValue: MINIMUM_NODE_WIDTH
                                }
                            ],
                            onUpdate: (data: Array<any>) => {
                                this.addWidget(new ImageWidget({
                                    image: data[0],
                                    maxWidth: data[1],
                                    maxHeight: data[2],
                                }));
                            }
                        }).Show();
                    }
                }
            ]
        };
    }

    public contextMenu(): ContextMenuConfig {
        let config: ContextMenuConfig = {
            group: nodeFlowGroup,
            items: [
                // {
                //     name: "Debug",
                //     callback: () => {
                //         console.log(this);
                //     }
                // }
            ],
            subMenus: [],
        }

        if (this.canEditPorts() || this.canEditTitle() || this.#canEditInfo) {

            const items = new Array<ContextMenuItemConfig>();
            if (this.canEditTitle()) {
                items.push({
                    name: "Title",
                    callback: () => {
                        this.#popupNodeTitleSelection();
                    }
                })
            }

            if (this.#canEditInfo) {
                items.push({
                    name: "Info",
                    callback: () => {
                        this.#popupNodeInfoSelection();
                    }
                })
            }

            const submenus = new Array<ContextMenuConfig>();
            if (this.canEditPorts()) {
                submenus.push({
                    name: "Add",
                    items: [
                        {
                            name: "Input",
                            callback: () => {
                                FormPopup({
                                    title: "New Input",
                                    form: [
                                        {
                                            name: "name",
                                            type: "text",
                                            startingValue: "input"
                                        },
                                        {
                                            name: "type",
                                            type: "text",
                                            startingValue: "string"
                                        }
                                    ],
                                    onUpdate: (data: Array<any>) => {
                                        this.addInput({
                                            name: data[0],
                                            type: data[1]
                                        })
                                    }
                                }).Show();
                            }
                        },
                        {
                            name: "Output",
                            callback: () => {
                                FormPopup({
                                    title: "New Output",
                                    form: [
                                        {
                                            name: "name",
                                            type: "text",
                                            startingValue: "output"
                                        },
                                        {
                                            name: "type",
                                            type: "text",
                                            startingValue: "string"
                                        }
                                    ],
                                    onUpdate: (data: Array<any>) => {
                                        this.addOutput({
                                            name: data[0],
                                            type: data[1]
                                        })
                                    }
                                }).Show();
                            }
                        },
                    ],
                    subMenus: [
                        this.#widgetSubmenu(),
                    ]
                });
            }

            config.subMenus?.push({
                group: nodeFlowGroup,
                name: "Edit",
                items: items,
                subMenus: submenus,
            })
        }

        if (this.locked()) {
            config.items?.push({
                name: "Unlock Node Position",
                group: nodeFlowGroup,
                callback: this.unlock.bind(this),
            });
        } else {
            config.items?.push({
                name: "Lock Node Position",
                group: nodeFlowGroup,
                callback: this.lock.bind(this),
            })
        }

        if (this.#contextMenu !== null) {
            config = CombineContextMenus(config, this.#contextMenu)
        }

        return config;
    }

    public unselect(): void {
        if (!this.#selected) {
            return;
        }
        this.#selected = false;
        for (let i = 0; i < this.#onUnselect.length; i++) {
            this.#onUnselect[i]();
        }
    }

    public addUnselectListener(callback: () => void): void {
        this.#onUnselect.push(callback);
    }

    public addSelectListener(callback: () => void): void {
        this.#onSelect.push(callback);
    }

    public dropFile(file: File): void {
        for (let i = 0; i < this.#onFiledrop.length; i++) {
            this.#onFiledrop[i](file);
        }
    }

    public addFileDropListener(callback: (file: File) => void): void {
        this.#onFiledrop.push(callback);
    }

    public locked(): boolean {
        return this.#locked;
    }

    public lock(): void {
        this.#locked = true;
    }

    public unlock(): void {
        this.#locked = false;
    }

    public setPosition(position: Vector2): void {
        CopyVector2(this.#position, position);
    }

    public getPosition(): Vector2 {
        return this.#position;
    }

    // #measureTitleText(ctx: CanvasRenderingContext2D, scale: number): Vector2 {
    //     return this.#titleTextStyle.measure(ctx, scale, this.#title);
    // }

    public calculateBounds(ctx: CanvasRenderingContext2D, camera: Camera): Box {
        const tempMeasurement = Zero();

        const doublePadding = this.#padding * 2;

        const screenSpacePosition = Zero();
        camera.graphSpaceToScreenSpace(this.#position, screenSpacePosition);

        const size = Zero();
        this.#title.size(ctx, 1, size);

        const subtitleSize = Zero();
        this.#subTitle.size(ctx, 1, subtitleSize);
        size.x = Math.max(size.x, subtitleSize.x);

        if (this.#infoText !== "") {
            size.x += (size.y * 4);
        }

        size.x += doublePadding;
        size.y += doublePadding + (this.#elementSpacing * this.#input.length);

        for (let i = 0; i < this.#input.length; i++) {
            const port = this.#input[i];
            this.#portTextStyle.measure(ctx, 1, port.getDisplayName(), tempMeasurement);
            size.y += tempMeasurement.y;
            size.x = Math.max(size.x, tempMeasurement.x + doublePadding)
        }

        size.y += (this.#elementSpacing * this.#output.length);

        for (let i = 0; i < this.#output.length; i++) {
            const port = this.#output[i];
            this.#portTextStyle.measure(ctx, 1, port.getDisplayName(), tempMeasurement);
            size.y += tempMeasurement.y;
            size.x = Math.max(size.x, tempMeasurement.x + doublePadding)
        }

        size.y += (this.#elementSpacing * this.#widgets.length);
        for (let i = 0; i < this.#widgets.length; i++) {
            const element = this.#widgets[i];
            const eleSize = element.Size();
            size.y += eleSize.y
            size.x = Math.max(size.x, (eleSize.x) + doublePadding)
        }

        // Add some padding at the end!
        size.y += this.#elementSpacing

        size.x = Math.max(size.x, MINIMUM_NODE_WIDTH)
        ScaleVector(size, camera.zoom);

        return {
            Position: screenSpacePosition,
            Size: size,
        }
    }

    addInput(config: PortConfig): Port {
        const port = new Port(this, config.array ? PortType.InputArray : PortType.Input, config);
        this.#input.push(port);
        return port;
    }

    addOutput(config: PortConfig): Port {
        const port = new Port(this, PortType.Output, config);
        this.#output.push(port);
        return port;
    }

    addWidget(widget: Widget): void {
        this.#widgets.push(widget);
    }

    getWidget(index: number): Widget {
        return this.#widgets[index];
    }

    widgetCount(): number {
        return this.#widgets.length;
    }

    translate(delta: Vector2): void {
        this.#position.x += delta.x;
        this.#position.y += delta.y;
    }

    inBounds(ctx: CanvasRenderingContext2D, camera: Camera, position: Vector2): NodeIntersection {
        var intersection: NodeIntersection = {}

        const box = this.calculateBounds(ctx, camera);
        if (InBox(box, position)) {
            intersection.Node = this;
        }

        for (let i = 0; i < this.#inputPortPositions.Count(); i++) {
            if (InBox(this.#inputPortPositions.At(i), position)) {
                intersection.Node = this;
                intersection.PortIndex = i;
                intersection.PortIsInput = true;
                intersection.Port = this.#input[i]
            }
        }

        for (let i = 0; i < this.#outputPortPositions.Count(); i++) {
            if (InBox(this.#outputPortPositions.At(i), position)) {
                intersection.Node = this;
                intersection.PortIndex = i;
                intersection.PortIsInput = false;
                intersection.Port = this.#output[i];
            }
        }

        for (let i = 0; i < this.#widgetPositions.Count(); i++) {
            if (InBox(this.#widgetPositions.At(i), position)) {
                intersection.Node = this;
                intersection.WidgetIndex = i;
                intersection.Widget = this.#widgets[i];
            }
        }

        return intersection;
    }

    canEditTitle(): boolean {
        return this.#canEditTitle;
    }

    canEditPorts(): boolean {
        return this.#canEditPorts;
    }

    title(): string {
        return this.#title.get();
    }

    setTitle(newTitle: string): void {
        if (!this.#canEditTitle) {
            console.warn("setTitle instruction ignored, as node has been marked un-editable");
            return;
        }

        let cleaned = newTitle;
        if (cleaned === null || cleaned === undefined) {
            cleaned = "";
        }

        const old = this.title();
        if (cleaned === old) {
            return;
        }

        this.#title.set(cleaned);

        for (let i = 0; i < this.#titleChangeCallback.length; i++) {
            const callback = this.#titleChangeCallback[i];
            callback(this, old, cleaned);
        }
    }

    setInfo(newInfo: string): void {
        if (!this.#canEditInfo) {
            console.warn("setInfo instruction ignored, as node has been marked un-editable");
        }


        let cleaned = newInfo;
        if (cleaned === null || cleaned === undefined) {
            cleaned = "";
        }

        if (cleaned === this.#infoText) {
            return;
        }

        const old = this.#infoText;
        this.#infoText = cleaned;

        for (let i = 0; i < this.#infoChangeCallback.length; i++) {
            const callback = this.#infoChangeCallback[i];
            callback(this, old, cleaned);
        }
    }

    inputPortPosition(index: number): Box {
        return this.#inputPortPositions.At(index);
    }

    inputPort(index: number): Port {
        return this.#input[index];
    }

    inputs(): number {
        return this.#input.length;
    }

    outputPortPosition(index: number): Box {
        return this.#outputPortPositions.At(index);
    }

    outputPort(index: number): Port {
        return this.#output[index];
    }

    outputs(): number {
        return this.#output.length;
    }

    #calculateStyle(state: NodeState): BoxStyle {
        // Let the node being selected override the idle style
        if (this.#selected && state === NodeState.Idle) {
            return this.#selectedStyle;
        }

        let boxStyle = this.#stateStyles.get(state);
        if (boxStyle === undefined) {
            throw new Error("no registered border style for state: " + state)
        }
        return boxStyle;
    }

    render(ctx: CanvasRenderingContext2D, camera: Camera, state: NodeState, mousePosition: Vector2 | undefined, postProcess: PassSubsystem): void {
        VectorPool.run(() => {
            const tempMeasurement = VectorPool.get();

            this.#inputPortPositions.Clear();
            this.#outputPortPositions.Clear();
            this.#widgetPositions.Clear();
            const scaledPadding = this.#padding * camera.zoom;
            const scaledElementSpacing = this.#elementSpacing * camera.zoom;

            const nodeBounds = this.calculateBounds(ctx, camera);

            // Background
            const nodeStyle = this.#calculateStyle(state);
            nodeStyle.Draw(ctx, nodeBounds, camera.zoom);

            // Title
            const borderSize = nodeStyle.borderSize();
            ctx.textAlign = TextAlign.Center;
            ctx.textBaseline = TextBaseline.Middle;

            const titleSize = VectorPool.get();
            this.#title.size(ctx, camera.zoom, titleSize);

            const subtitleSize = VectorPool.get();
            this.#subTitle.size(ctx, camera.zoom, subtitleSize);

            const titleBoxSize = VectorPool.get();
            titleBoxSize.x = nodeBounds.Size.x;
            titleBoxSize.y = titleSize.y + (scaledPadding * 2);

            ctx.fillStyle = this.#titleColor;
            ctx.beginPath();
            const titleX = nodeBounds.Position.x + (borderSize * camera.zoom * 0.5)
            const titleY = nodeBounds.Position.y + (borderSize * camera.zoom * 0.5)
            const titleWidth = titleBoxSize.x - (borderSize * camera.zoom);
            const titleHeight = titleBoxSize.y - (borderSize * camera.zoom * 0.5);
            ctx.roundRect(
                titleX, titleY, titleWidth, titleHeight,
                [nodeStyle.radius() * camera.zoom, nodeStyle.radius() * camera.zoom, 0, 0]
            );
            ctx.fill();
            // ctx.stroke();

            const titlePosition = VectorPool.get();
            titlePosition.x = nodeBounds.Position.x + (nodeBounds.Size.x / 2)
            titlePosition.y = nodeBounds.Position.y + scaledPadding + (titleSize.y / 2)

            if (this.#subTitle.get() !== "") {
                const subtitlePosition = VectorPool.get();
                CopyVector2(subtitlePosition, titlePosition);

                // TODO: I'm fudging a bunch of numbers ot make it fit nicely 
                // together. 
                // 
                // Need to come up with like, proper logic about how we ensure 
                // title and subtitle fit together
                subtitlePosition.y -= titleSize.y / 1.5;
                titlePosition.y += scaledPadding / 2

                this.#subTitle.render(ctx, camera.zoom, subtitlePosition);
            }

            this.#title.render(ctx, camera.zoom, titlePosition);

            // Info symbol
            if (this.#infoText !== "") {
                const infoRadius = titleHeight * .25;
                const centerX = titleX + titleWidth - (titleHeight * .25) - infoRadius;
                const centerY = titleY + (titleHeight * .25) + infoRadius;

                const infoPosition = VectorPool.get();
                infoPosition.x = centerX;
                infoPosition.y = centerY + (titleHeight * .025);

                let infoLineThickness = 1.5 * camera.zoom;

                if (mousePosition && Distance(infoPosition, mousePosition) <= infoRadius) {
                    infoLineThickness *= 1.5;

                    // This is a slightly expensive function if we're not 
                    // caching, but it only executes while we're mousing over 
                    // the info symbol, so I'm not particularly obligated to
                    // optimize it. 
                    //
                    // If you're just bored, def cache the split string method,
                    // and figure out a system to recalculate as a node has its
                    // title, port, or widgets change.
                    //
                    // Should probably break out the lambda into a proper 
                    // function as well. I think as it is, we're creating a new
                    // lambda function per frame?
                    postProcess.queue(() => {
                        this.#infoSymbol.style().setupStyle(ctx, camera.zoom);
                        ctx.textAlign = TextAlign.Center;

                        const infoBoxWidth = titleWidth * 1.5;
                        const textEntries = splitStringIntoLines(ctx, this.#infoText, infoBoxWidth);

                        const lineHeight = (this.#infoSymbol.style().getSize() + 2);
                        const infoBoxHeight = lineHeight * textEntries.length * camera.zoom;
                        const scaledLineHeight = lineHeight * camera.zoom;
                        const start = titleY - infoBoxHeight - (scaledLineHeight / 2);

                        // Draw box
                        ctx.fillStyle = this.#titleColor;
                        ctx.beginPath();
                        ctx.roundRect(
                            centerX - (infoBoxWidth / 2) - (scaledLineHeight / 2),
                            start - scaledLineHeight,
                            infoBoxWidth + scaledLineHeight,
                            infoBoxHeight + scaledLineHeight,
                            nodeStyle.radius() * camera.zoom
                        );
                        ctx.fill();

                        // Render Text
                        this.#infoSymbol.style().setupStyle(ctx, camera.zoom);
                        for (let i = 0; i < textEntries.length; i++) {
                            const entry = textEntries[i];
                            ctx.fillText(entry, centerX, start + (i * lineHeight * camera.zoom));
                        }
                    });
                }

                ctx.beginPath();
                ctx.arc(centerX, centerY, infoRadius, 0, 2 * Math.PI, false);
                ctx.lineWidth = infoLineThickness;
                ctx.strokeStyle = this.#infoSymbol.getColor();
                ctx.stroke();

                ctx.textAlign = TextAlign.Center;
                this.#infoSymbol.render(ctx, camera.zoom, infoPosition);
            }


            // Input Ports
            let startY = nodeBounds.Position.y + (scaledPadding * 2) + titleSize.y + scaledElementSpacing;
            const leftSide = nodeBounds.Position.x + scaledPadding;
            for (let i = 0; i < this.#input.length; i++) {
                ctx.textAlign = TextAlign.Left;
                const port = this.#input[i];
                this.#portTextStyle.measure(ctx, camera.zoom, port.getDisplayName(), tempMeasurement);
                const position = VectorPool.get();

                position.x = nodeBounds.Position.x;
                position.y = startY + (tempMeasurement.y / 2);

                // Text
                this.#portTextStyle.setupStyle(ctx, camera.zoom);
                ctx.fillText(port.getDisplayName(), leftSide, position.y);

                // Port
                this.#inputPortPositions.Push(port.render(ctx, position, camera, mousePosition, postProcess));

                startY += tempMeasurement.y + scaledElementSpacing;
            }

            // Output Ports
            const rightSide = nodeBounds.Position.x + nodeBounds.Size.x;
            ctx.textAlign = TextAlign.Right;
            for (let i = 0; i < this.#output.length; i++) {
                const port = this.#output[i];
                this.#portTextStyle.measure(ctx, camera.zoom, port.getDisplayName(), tempMeasurement);
                const position = VectorPool.get();
                position.x = rightSide;
                position.y = startY + (tempMeasurement.y / 2);

                // Text
                this.#portTextStyle.setupStyle(ctx, camera.zoom);
                ctx.fillText(port.getDisplayName(), rightSide - scaledPadding, position.y);

                // Port
                this.#outputPortPositions.Push(port.render(ctx, position, camera, mousePosition, postProcess));

                startY += tempMeasurement.y + scaledElementSpacing;
            }

            for (let i = 0; i < this.#widgets.length; i++) {
                const widget = this.#widgets[i];
                const widgetSize = widget.Size();
                const scaledWidgetWidth = widgetSize.x * camera.zoom;

                const position = VectorPool.get();
                position.x = nodeBounds.Position.x + ((nodeBounds.Size.x - scaledWidgetWidth) / 2);
                position.y = startY;

                this.#widgetPositions.Push(widget.Draw(ctx, position, camera.zoom, mousePosition));
                startY += (widgetSize.y * camera.zoom) + scaledElementSpacing;
            }
        })
    }
}

================
File: src/organize.ts
================
import { Camera } from "./camera";
import { NodeFlowGraph } from "./graph";
import { FlowNode } from "./node";
import { NodeSubsystem } from "./nodes/subsystem";
import { Box } from "./types/box";

// TODO: Cyclical dependencies will end our life

function MarkInputs(graph: NodeSubsystem, positions: Array<number>, nodeLUT: Map<FlowNode, number>, node: number, depth: number, shouldSort: Map<FlowNode, boolean>) {
    const inputs = graph.connectedInputsNodeReferencesByIndex(node);
    for (let i = 0; i < inputs.length; i++) {
        const nodeIndex = nodeLUT.get(inputs[i]) as number;

        if (!shouldSort.has(inputs[i])) {
            continue;
        }

        positions[nodeIndex] = depth;
        MarkInputs(graph, positions, nodeLUT, nodeIndex, depth - 1, shouldSort);
    }
}

function MarkOutputs(graph: NodeSubsystem, positions: Array<number>, nodeLUT: Map<FlowNode, number>, node: number, depth: number, shouldSort: Map<FlowNode, boolean>) {
    const outputs = graph.connectedInputsNodeReferencesByIndex(node);
    for (let i = 0; i < outputs.length; i++) {
        const nodeIndex = nodeLUT.get(outputs[i]) as number;

        if (!shouldSort.has(outputs[i])) {
            continue;
        }

        positions[nodeIndex] = depth;
        MarkOutputs(graph, positions, nodeLUT, nodeIndex, depth + 1, shouldSort);
    }
}

export function Organize(ctx: CanvasRenderingContext2D, graph: NodeSubsystem, nodesToSort?: Array<number>): void {
    const nodes = graph.getNodes();
    const nodeLUT = new Map<FlowNode, number>();
    const bounds = new Array<Box>(nodes.length);
    const relativePosition = new Array<Array<number>>(nodes.length);
    const claimed = new Array<boolean>(nodes.length);
    const shouldSort = new Map<FlowNode, boolean>(); // TODO: we don't really need a Map, is their a Set data structure?

    if (nodesToSort) {
        if (nodesToSort.length < 2) {
            return;
        }
        for (let i = 0; i < nodesToSort.length; i++) {
            shouldSort.set(nodes[nodesToSort[i]], true);
        }
    } else {
        for (let i = 0; i < nodes.length; i++) {
            shouldSort.set(nodes[i], true);
        }
    }

    const camera = new Camera();

    // Initialize everything
    for (let i = 0; i < nodes.length; i++) {
        bounds[i] = nodes[i].calculateBounds(ctx, camera);
        relativePosition[i] = new Array<number>(nodes.length);
        nodeLUT.set(nodes[i], i);
        claimed[i] = false;
    }

    for (let i = 0; i < nodes.length; i++) {
        relativePosition[i][i] = 0;
        MarkInputs(graph, relativePosition[i], nodeLUT, i, -1, shouldSort);
        MarkOutputs(graph, relativePosition[i], nodeLUT, i, 1, shouldSort);
    }

    interface entry {
        node: number;
        length: number;
        min: number;
        max: number
    }

    let entries = new Array<entry>(shouldSort.size);

    let nodeIndex = 0;
    for (let i = 0; i < nodes.length; i++) {
        if (!shouldSort.has(nodes[i])) {
            continue;
        }

        let min = 0;
        let max = 0;
        for (let x = 0; x < nodes.length; x++) {
            const val = relativePosition[i][x];
            if (val === undefined) {
                continue;
            }

            min = Math.min(min, val);
            max = Math.max(max, val);
        }
        entries[nodeIndex] = {
            length: max - min,
            node: i,
            min: min,
            max: max
        }
        nodeIndex++
    }


    entries.sort((a, b) => b.length - a.length);

    interface Column {
        Nodes: Array<FlowNode>;
        Width: number;
    }

    const columns = Array<Column>(entries[0].length + 1);
    for (let i = 0; i < columns.length; i++) {
        columns[i] = {
            Nodes: new Array<FlowNode>(),
            Width: 0
        };
    }

    for (let i = 0; i < entries.length; i++) {
        const entry = entries[i];
        if (claimed[entry.node] === true) {
            continue;
        }

        const positions = relativePosition[entry.node];

        for (let p = 0; p < positions.length; p++) {
            const position = positions[p];
            if (position === undefined) {
                continue;
            }

            if (claimed[p] === true) {
                continue;
            }

            const nodeBounds = bounds[p];
            const column = columns[position - entry.min];
            column.Nodes.push(nodes[p])
            column.Width = Math.max(column.Width, nodeBounds.Size.x)

            claimed[p] = true;
        }
    }

    let allColumnsWidths = 0;
    for (let c = 0; c < columns.length; c++) {
        allColumnsWidths += columns[c].Width;
    }

    const widthSpacing = 100;
    const heightSpacing = 50;

    let widthOffset = 0;
    for (let c = 0; c < columns.length; c++) {
        var column = columns[c];
        let heightOffset = 0;

        widthOffset -= widthSpacing + column.Width;

        for (let n = 0; n < column.Nodes.length; n++) {
            const node = column.Nodes[n];
            const nodeBounds = bounds[nodeLUT.get(node) as number];

            let pos = {
                x: widthOffset + allColumnsWidths + (columns.length * widthSpacing),
                y: heightOffset
            }

            heightOffset += nodeBounds.Size.y + heightSpacing
            node.setPosition(pos);
        }
    }

}

================
File: src/performance.ts
================
export function TimeExecution(name: string, callback: Function) {
    const start = name + "_Start";
    const end = name + "_End";

    performance.mark(start);
    callback();
    performance.mark(end);
    performance.measure(name, start, end);
}

================
File: src/popup.ts
================
export interface PopupConfig {
    title: string;
    options: Array<string>;

    onClose?: (button: string | null) => void;
    content?: () => Element;
    buttonCSS?: string;
}

export class Popup {

    #title: string;

    #options: Array<string>;

    #content?: () => Element;

    #onClose?: (button: string | null) => void;

    // Styling ================================================================

    #buttonCSS: string;

    // Runtime ================================================================

    #popup: HTMLDivElement | null;

    constructor(config: PopupConfig) {
        this.#title = config.title;
        this.#options = config.options;
        this.#content = config.content;
        this.#onClose = config.onClose;
        this.#buttonCSS = config.buttonCSS === undefined ? "flex-grow: 1; margin-right: 8px;" : config.buttonCSS;
        this.#popup = null;
    }

    Hide(): void {
        if (this.#popup === null) {
            return;
        }
        document.body.removeChild(this.#popup);
        this.#popup = null;
    }

    Show(): void {
        this.#popup = document.createElement('div');
        this.#popup.style.cssText = 'position:absolute;top:0;width:100%;display:flex;height:100%;justify-content:center;align-items:center;background-color:#00000070;';
        document.body.appendChild(this.#popup);

        const container = document.createElement('div');
        container.style.cssText = 'background-color:#000;color:white;font-family:Verdana;border-radius:8px;padding:16px;';
        this.#popup.appendChild(container);

        const title = document.createElement("h2");
        title.textContent = this.#title;
        title.style.cssText = "margin-top:0;margin-bottom:16px;";
        container.appendChild(title)

        if (this.#content !== undefined) {
            container.appendChild(this.#content());
        }

        const buttonContainer = document.createElement("div");
        buttonContainer.style.cssText = 'margin-top:16px;justify-content:space-around;align-items:center;flex-direction:row;display:flex;';
        container.appendChild(buttonContainer);

        for (let i = 0; i < this.#options.length; i++) {
            const button = document.createElement("button");
            button.style.cssText = this.#buttonCSS;
            button.textContent = this.#options[i];
            button.onclick = () => {
                this.Hide();
                if (this.#onClose !== undefined) {
                    this.#onClose(this.#options[i]);
                }
            };
            buttonContainer.appendChild(button);
        }
    }

}

================
File: src/port.ts
================
import { Camera } from "./camera";
import { Connection } from './connection';
import { FlowNode } from "./node";
import { PassSubsystem } from "./pass/subsystem";
import { TextAlign } from "./styles/canvasTextAlign";
import { Box, BoxIntersection, InBox } from "./types/box";
import { Vector2 } from "./types/vector2";
import { Color, HSV, HSV2RGB, RgbToHex } from "./utils/color";

export enum PortType {
    Input = "INPUT",
    Output = "OUTPUT",
    InputArray = "INPUTARRAY",
}

export interface PortStyle {
    size?: number;
    fillColor?: string;
    borderColor?: string;
    borderSize?: number;
}

type ConnectionChangeCallback = (connection: Connection, connectionIndex: number, port: Port, portType: PortType, node: FlowNode) => void

export interface PortConfig {
    name?: string;
    type?: string;
    array?: boolean;
    emptyStyle?: PortStyle;
    filledStyle?: PortStyle;
    onConnectionAdded?: ConnectionChangeCallback;
    onConnectionRemoved?: ConnectionChangeCallback;
};

// Calculate a color hash for an arbirary type
function fallbackColor(type: string, s: number): string {
    let value = 0;
    for (var i = 0; i < type.length; i++) {
        value += type.charCodeAt(i) * (i + 1);
    }

    const mod = 24;
    value = Math.round(value) % mod;

    const hsv: HSV = { h: (value / (mod - 1)) * 360, s: s, v: 1 };
    const color: Color = { r: 0, g: 0, b: 0 };
    HSV2RGB(hsv, color);
    return RgbToHex(color);
}

export class Port {

    #node: FlowNode;

    #displayName: string;

    #emptyStyle: PortStyle;

    #filledStyle: PortStyle;

    #connections: Array<Connection>;

    #portType: PortType

    #dataType: string;

    #onConnectionAdded: Array<ConnectionChangeCallback>;

    #onConnectionRemoved: Array<ConnectionChangeCallback>;;

    constructor(node: FlowNode, portType: PortType, config?: PortConfig) {
        this.#node = node;
        this.#connections = new Array<Connection>();
        this.#portType = portType;
        this.#displayName = config?.name === undefined ? "Port" : config?.name;
        this.#dataType = config?.type === undefined ? "" : config?.type;

        this.#emptyStyle = {
            borderColor: config?.emptyStyle?.borderColor === undefined ? "#1c1c1c" : config.emptyStyle?.borderColor,
            fillColor: config?.emptyStyle?.fillColor === undefined ? fallbackColor(this.#dataType, 0.3) : config.emptyStyle?.fillColor,
            borderSize: config?.emptyStyle?.borderSize === undefined ? 1 : config.emptyStyle?.borderSize,
            size: config?.emptyStyle?.size === undefined ? 4 : config.emptyStyle?.size
        }

        this.#filledStyle = {
            borderColor: config?.filledStyle?.borderColor === undefined ? "#1c1c1c" : config.filledStyle?.borderColor,
            fillColor: config?.filledStyle?.fillColor === undefined ? fallbackColor(this.#dataType, 1) : config.filledStyle?.fillColor,
            borderSize: config?.filledStyle?.borderSize === undefined ? 1 : config.filledStyle?.borderSize,
            size: config?.filledStyle?.size === undefined ? 5 : config.filledStyle?.size
        }

        this.#onConnectionAdded = new Array<ConnectionChangeCallback>();
        if (config?.onConnectionAdded) {
            this.#onConnectionAdded.push(config?.onConnectionAdded);
        }

        this.#onConnectionRemoved = new Array<ConnectionChangeCallback>();
        if (config?.onConnectionRemoved) {
            this.#onConnectionRemoved.push(config?.onConnectionRemoved);
        }
    }

    addConnection(connection: Connection): void {
        const c = this.#connections.length;
        this.#connections.push(connection);
        for (let i = 0; i < this.#onConnectionAdded.length; i++) {
            this.#onConnectionAdded[i](connection, c, this, this.#portType, this.#node);
        }
    }

    replaceConnection(connection: Connection, index: number): void {
        const c = this.#connections.length;
        this.#connections[index] = connection;
        for (let i = 0; i < this.#onConnectionAdded.length; i++) {
            this.#onConnectionAdded[i](connection, c, this, this.#portType, this.#node);
        }
    }

    addConnectionAddedListener(callback: ConnectionChangeCallback) {
        if (callback === undefined) {
            return;
        }
        this.#onConnectionAdded.push(callback);
    }

    connections(): Array<Connection> {
        return this.#connections;
    }

    addConnectionRemovedListener(callback: ConnectionChangeCallback) {
        if (callback === undefined) {
            return;
        }
        this.#onConnectionRemoved.push(callback);
    }

    clearConnection(connection: Connection): void {
        const index = this.#connections.indexOf(connection);
        if (index > -1) {
            this.#connections.splice(index, 1);
            for (let i = 0; i < this.#onConnectionRemoved.length; i++) {
                this.#onConnectionRemoved[i](connection, index, this, this.#portType, this.#node);
            }
        } else {
            console.error("no connection found to remove");
        }
    }

    getDataType(): string {
        return this.#dataType;
    }

    getPortType(): PortType {
        return this.#portType;
    }

    getDisplayName(): string {
        return this.#displayName;
    }

    filledStyleColor(): string {
        if (this.#filledStyle.fillColor === undefined) {
            console.error("There's no fill color!!!!!!!!!")
            return "black";
        }
        return this.#filledStyle.fillColor;
    }

    #box: Box = { Position: { x: 0, y: 0 }, Size: { x: 0, y: 0 } };

    render(ctx: CanvasRenderingContext2D, position: Vector2, camera: Camera, mousePosition: Vector2 | undefined, postProcess: PassSubsystem): Box {
        let style = this.#emptyStyle;
        if (this.#connections.length > 0) {
            style = this.#filledStyle;
        }

        let scaledRadius = style.size as number * camera.zoom

        if (mousePosition && InBox(this.#box, mousePosition)) {
            scaledRadius *= 1.25;

            // Redeclare so lambda is ensured to use these values
            const xPos = position.x;
            const yPos = position.y;

            postProcess.queue(() => {
                ctx.textAlign = TextAlign.Center;

                const padding = 13;
                const measurement = ctx.measureText(this.#dataType)
                const w = measurement.width + (padding * camera.zoom);

                ctx.beginPath();
                ctx.fillStyle = "rgba(0, 0, 0, 0.75)";
                ctx.roundRect(xPos - w / 2, yPos + (scaledRadius * 3) - (padding * camera.zoom), w, (padding * 2) * camera.zoom, 4 * camera.zoom);
                ctx.fill();

                ctx.fillStyle = "#FFFFFF";
                ctx.fillText(this.#dataType, xPos, yPos + (scaledRadius * 3));
            })
        }

        this.#box.Position.x = position.x - scaledRadius;
        this.#box.Position.y = position.y - scaledRadius;
        this.#box.Size.x = scaledRadius * 2;
        this.#box.Size.y = scaledRadius * 2;

        ctx.strokeStyle = style.borderColor as string;
        ctx.fillStyle = style.fillColor as string;

        ctx.beginPath();
        if (this.#portType === PortType.InputArray) {
            ctx.rect(position.x - scaledRadius, position.y - scaledRadius, scaledRadius * 2, scaledRadius * 2)
        } else {
            ctx.arc(position.x, position.y, scaledRadius, 0, 2 * Math.PI);
        }
        ctx.fill();
        ctx.stroke();


        return this.#box;
    }
}

================
File: src/quickMenu.ts
================
import { ContextMenuConfig, ContextMenuItemConfig } from "./contextMenu";
import { ContainerRenderElement as ContainerElement } from "./elements/container";
import { IRenderElement } from "./elements/interfaces";
import { TextAlign, TextElement as TextElement, VerticalAlign } from "./elements/text";
import { FontWeight } from "./styles/text";
import { Theme } from "./theme";
import { Text } from './types/text';
import { ScaleVector, Vector2 } from './types/vector2';
import { Display } from './elements/base';

class QuickMenuGroup {

    #text: TextElement;

    public items: Array<QuickMenuItem>;

    constructor(text: TextElement, items: Array<QuickMenuItem>) {
        this.#text = text;
        this.items = items;
    }

    updateRendering(terms: Array<string>): void {
        let shouldRender = false;
        for (let i = 0; i < this.items.length; i++) {
            const kept = this.items[i].filter(terms);
            this.items[i].render(kept);
            if (kept) {
                shouldRender = true;
            }
        }

        this.#text.setDisplay(shouldRender ? Display.Flex : Display.None);
    }

}

class QuickMenuItem {
    #searchText: string;
    #text: TextElement;
    #context: ContextMenuItemConfig

    constructor(searchText: string, text: TextElement, context: ContextMenuItemConfig) {
        this.#searchText = searchText.toLowerCase();
        this.#text = text;
        this.#context = context;
    }

    filter(terms: Array<string>): boolean {
        if (terms.length === 0) {
            return true;
        }
        for (let i = 0; i < terms.length; i++) {
            if (terms[i] === "") {
                continue;
            }

            if (this.#searchText.indexOf(terms[i]) === -1) {
                return false;
            }
        }
        return true;
    }

    render(render: boolean): void {
        this.#text.setDisplay(render ? Display.Flex : Display.None);
    }

    rendering(): boolean {
        return this.#text.getDisplay() === Display.Flex;
    }

    highlight(highlight: boolean): void {
        this.#text.setBackgroundColor(highlight ? Theme.ContextMenu.HighlightColor : "");
    }

    select(): void {
        if (this.#context.callback) {
            this.#context.callback()
        }
    }
}

function RecurseBuildContainers(
    path: string,
    config: ContextMenuConfig,
    renderElements: Array<IRenderElement>,
    groups: Array<QuickMenuGroup>
): void {

    let currentPath = config?.name ?? "";
    if (path !== "") {
        currentPath = path + " / " + currentPath;
    }

    if (config?.items && config.items.length > 0) {
        const titleText = new TextElement(
            new Text(
                currentPath,
                {
                    color: Theme.ContextMenu.FontColor,
                    weight: FontWeight.Bold,
                    size: 12,
                }
            ),
            {
                Align: TextAlign.Center,
                VerticalAlign: VerticalAlign.Center,
                Padding: 16
            }
        );
        renderElements.push(titleText);

        const quickItems = new Array<QuickMenuItem>();

        for (let i = 0; i < config.items.length; i++) {
            const configItem = config.items[i];

            const itemText = new TextElement(
                new Text(
                    configItem.name ?? "Item",
                    {
                        color: Theme.ContextMenu.FontColor,
                    }
                ),
                {
                    Padding: 8
                }
            );

            quickItems.push(new QuickMenuItem(
                currentPath + (configItem.name ?? ""),
                itemText,
                configItem
            ));

            renderElements.push(itemText);
        }

        groups.push(new QuickMenuGroup(titleText, quickItems));
    }

    if (config?.subMenus) {
        for (let i = 0; i < config?.subMenus.length; i++) {
            const configItem = config?.subMenus[i];
            RecurseBuildContainers(currentPath, configItem, renderElements, groups);
        }
    }
}

export class QuickMenu {

    #menuGroups: Array<QuickMenuGroup>

    #container: ContainerElement

    #searchText: Text;

    #currentSelection: number;

    constructor(config?: ContextMenuConfig) {
        this.#menuGroups = [];
        this.#currentSelection = 0;

        this.#searchText = new Text(
            "",
            {
                color: Theme.ContextMenu.FontColor,
            }
        );

        const elements = [
            new TextElement(
                new Text(
                    "Search",
                    {
                        color: Theme.ContextMenu.FontColor,
                    }
                ),
                {
                    Padding: {
                        Bottom: 0,
                        Left: 8,
                        Right: 8,
                        Top: 8
                    },
                }
            ),

            // Search Box...
            new ContainerElement(
                [
                    new TextElement(
                        this.#searchText,
                        undefined
                    ),
                ],
                {
                    Border: {
                        Radius: 2,
                    },
                    BackgroundColor: "#003847",
                    Padding: 8,
                    Margin: 8,
                    MinHeight: 46,
                }
            ),
        ]

        if (config) {
            RecurseBuildContainers("", config, elements, this.#menuGroups);
        }

        this.#container = new ContainerElement(
            elements,
            {
                BackgroundColor: Theme.ContextMenu.BackgroundColor,
                Border: {
                    Thickness: 1,
                    Radius: 4
                }
            }
        )

        this.#updateHighlighting();
    }

    execute(): void {
        let selection = this.#currentSelection;

        for (let groupIndex = 0; groupIndex < this.#menuGroups.length; groupIndex++) {
            const group = this.#menuGroups[groupIndex];

            for (let itemIndex = 0; itemIndex < group.items.length; itemIndex++) {
                if (group.items[itemIndex].rendering()) {
                    if (selection === 0) {
                        group.items[itemIndex].select();
                        return;
                    }
                    selection--;
                }
            }
        }
    }

    #updateHighlighting(): void {
        const searchText = this.#searchText
            .get()
            .trim()
            .toLowerCase();

        let terms = new Array<string>();
        if (searchText !== "") {
            var potentialTerms = searchText.split(" ");
            for (let i = 0; i < potentialTerms.length; i++) {
                const cleaned = potentialTerms[i].trim();
                if (cleaned !== "") {
                    terms.push(cleaned);
                }
            }
        }

        let selection = this.#currentSelection;

        for (let groupIndex = 0; groupIndex < this.#menuGroups.length; groupIndex++) {
            const group = this.#menuGroups[groupIndex];
            group.updateRendering(terms);

            for (let itemIndex = 0; itemIndex < group.items.length; itemIndex++) {
                if (group.items[itemIndex].rendering()) {
                    group.items[itemIndex].highlight(selection === 0)
                    selection--;
                }
            }
        }
    }

    keyboardEvent(event: KeyboardEvent): void {

        let intercepted = true;

        if (event.code === "Backspace") {
            this.#currentSelection = 0;
            const text = this.#searchText.get();
            this.#searchText.set(text.slice(0, text.length - 1));
        } else if (/^[a-zA-Z0-9]$/.test(event.key) || event.key === " ") {
            this.#currentSelection = 0;
            this.#searchText.set(this.#searchText.get() + event.key);
        } else if (event.key === "ArrowUp") {
            this.#currentSelection = Math.max(0, this.#currentSelection - 1);
        } else if (event.key === "ArrowDown") {
            this.#currentSelection ++;
        } else {
            intercepted = false;
        }

        if (intercepted) {
            this.#updateHighlighting();
            event.preventDefault();
        }

        // console.log(event);
    }

    renderSize = { x: 0, y: 0 };

    public render(ctx: CanvasRenderingContext2D, pos: Vector2, graphScale: number, mousePosition: Vector2 | undefined): null {
        this.#container.calcSize(ctx, this.renderSize, { x: -1, y: -1 });
        // ScaleVector(this.renderSize, graphScale);

        // Clamp the position so it's not spilling off the canvas
        if (pos.y + Math.min(this.renderSize.y, 400) > ctx.canvas.clientHeight) {
            pos.y = ctx.canvas.clientHeight - Math.min(this.renderSize.y, 400);
        }

        if (pos.x + this.renderSize.x > ctx.canvas.clientWidth) {
            pos.x = ctx.canvas.clientWidth - this.renderSize.x;
        }

        if (pos.y < 0) {
            pos.y = 0;
        }

        if (pos.x < 0) {
            pos.x = 0;
        }

        this.#container.render(ctx, pos, 1, this.renderSize);
        return null;
    }
}

================
File: src/theme.ts
================
export const Theme = {
    FontFamily: "Courier New",
    Graph: {
        BackgroundColor: "#07212a",
    },
    Node: {
        FontColor: "#afb9bb",
        BackgroundColor: "#0c2b35",
        Title: {
            Color: "#154050",
            FontColor: "#afb9bb",
            Padding: 5
        },
        BorderRadius: 15,
        Border: {
            Idle: "#1c1c1c",
            MouseOver: "#8e8e8e",
            Grabbed: "white",
            Selected: "#6e6e6e"
        },
        Port: {
            FontColor: "#afb9bb"
        }
    },
    BoxSelect: {
        Color: "white",
        Size: 1,
        Radius: 2,
        LineDashLength: 5,
    },
    Widget: {
        FontColor: "#afb9bb",
        BackgroundColor: "#0f313c",
        Border: {
            Color: "#154050",
            Size: 2,
            Radius: 2
        },
        Hover: {
            BackgroundColor: "#195366"
        },
        Slider: {
            FillColor: "#07212A",
        },
        Button: {
            Click: {
                BackgroundColor: "#1f637a"
            },
        }
    },
    ContextMenu: {
        BackgroundColor: "#07212A",
        HighlightColor: "#205A6D",
        FontColor: "#afb9bb",
    },
    Note: {
        FontColor: "#afb9bb",
        FontSize: 16,
        EntrySpacing: 20,
        LineSpacing: 5,
        DotSize: 3,
        HeaderLineWidth: 2,
        H1: {
            FontSize: 32,
        },
        H2: {
            FontSize: 16,
        },
        H3: {
            FontSize: 16,
        },
        CodeBlock: {
            BackgroundColor: "#0c2b35",
            Padding: 16,
            BorderRadius: 4,
        }
    }
}

================
File: .gitignore
================
dist
node_modules

================
File: .npmignore
================
node_modules/
.git/
.npmignore

================
File: dev.tsconfig.json
================
{
    "compilerOptions": {
        "declaration": true, 
        "outFile": "./dist/js/NodeFlow.js", 
        "sourceMap": true, 
        "strict": true, 
        "module": "AMD", 
        "target": "ESNext"
    },

    "include": [
        "src/index.ts"
    ], 

    "exclude": [
        "node_modules"
    ] 
}

================
File: esbuild.ts
================
import { build, serve, BuildOptions } from 'esbuild';

const buildOptsWeb: BuildOptions = {
  entryPoints: ['./src/index.ts'],
  outfile: './dist/web/NodeFlow.js',
  platform: 'browser',
  target: ['esNext'],
  //   format: 'cjs',
  bundle: true,
  sourcemap: true,
  minify: true,
  treeShaking: true,
};

const serveOpts = { servedir: './' };
const flags = process.argv.filter(arg => /--[^=].*/.test(arg));
const enableWatch = (flags.includes('--watch'));

if (enableWatch) {
  buildOptsWeb.watch = {
    onRebuild: (error, result) => {
      if (error) { console.error('watch web development build failed:', error); }
      else { console.log('watch web development build succeeded:', result); }
    }
  };

  serve(serveOpts, {}).then((result) => {
    console.log(`serving extension from "${serveOpts.servedir}" at "http://${result.host}:${result.port}"`);
  });
}

build(buildOptsWeb).then(() => enableWatch ? console.log("watching web development build...") : null);

================
File: index.html
================
<html>

<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>Node Flow Demo</title>
    <link rel="shortcut icon" href="#" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=swap"
        rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        html,
        body {
            width: 100%;
            height: 100%;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
    </style>

    <script src="./dist/index.mjs" type="module"></script>
</head>

<body>
    <canvas id="canvas"></canvas>
    <script type="module">
        import { Theme, FlowNode, NodeFlowGraph, FlowNote } from "./dist/index.mjs";

        const canvas = document.getElementById("canvas");
        Theme.FontFamily = "Source Code Pro";

        const node3 = new FlowNode({
            title: "Node 3",
            position: { x: 850, y: 150 },
            inputs: [
                { name: "test input 1", type: "int" }
            ],
            outputs: [
                { name: "float", type: "float32" }
            ],
            widgets: [
                {
                    type: "slider",
                    config: {
                        min: 0,
                        max: 5,
                        value: 2.5,
                        snapIncrement: .25
                    }
                }
            ]
        });

        const graph = new NodeFlowGraph(canvas, {
            nodes: {
                publishers: {
                    "example": {
                        name: "Example",
                        description: "Bunch of example nodes",
                        version: "v1.0.0",
                        nodes: {
                            "empty": {
                                title: "Empty Node",
                                canEditTitle: true,
                                canEditPorts: true,
                                canEditInfo: true
                            },
                            "widgets/slider": {
                                title: "Slider Node",
                                widgets: [
                                    {
                                        type: "slider",
                                        config: {
                                            value: 0.5,
                                        }
                                    }
                                ],
                                outputs: [
                                    {
                                        name: "out",
                                        type: "float32"
                                    }
                                ]
                            },
                            "widgets/color": {
                                title: "Color Node",
                                widgets: [
                                    {
                                        type: "color",
                                        config: {
                                        }
                                    }
                                ],
                                outputs: [
                                    {
                                        name: "out",
                                        type: "color"
                                    }
                                ]
                            },
                            "widgets/text": {
                                title: "Text Node",
                                widgets: [
                                    {
                                        type: "text",
                                        config: {
                                            value: "Arbitrary Text"
                                        }
                                    }
                                ],
                                outputs: [
                                    {
                                        name: "out",
                                        type: "color"
                                    }
                                ]
                            }
                        }
                    },
                },
            },
            board: {
                notes: [
                    {
                        text: `
# Notes

This is an example of a *note* written in **markdown**.

You can place notes around your graph to help explain your graph to other users.

## Editting

*Right-click* on this note and select "Edit Note" to put your text here!

## Support

This is a minimal implementation with graph-specific functionality. Currently implemented features are:

* H1, H2, and H3
* Bold and Italic
* Unordered Lists
* Code blocks
`,
                        position: {
                            x: 2300,
                            y: 20
                        },
                        locked: true,
                    },
                    {
                        position: {
                            x: 20,
                            y: 20
                        },
                        locked: true,
                        text: `
# Node Flow

Node Flow is a javascript library that enables developers to build node based tools similar to Unreal Blueprints or Blender Nodes. 

## Example

Scattered across this graph contains code snippets on how to accomplish different things within the library.

\`\`\`
// Create a canvas to render our graph to
let canvas = document.createElement("canvas");

// Create our Node Flow Graph
let graph = new NodeFlowGraph(canvas)
\`\`\`
`
                    },

                ]
            }
        });

        graph.addNote(new FlowNote({
            position: { x: 800, y: 20 },
            locked: true,
            text: `
## Inputs and Outputs

Create a Add node that takes two numbers and outputs a single number

\`\`\`
let node = new FlowNode({ 
    title: "Add",
    info:  "I add two numbers",
    inputs: [
        { name: "a", type: "float32" },
        { name: "b", type: "float32" }
    ],
     outputs: [
        { name: "sum", type: "float32" }
    ],
});
graph.addNode(node);
\`\`\`

You can also add additional inputs and outputs to the node after it's been created

\`\`\`
node.addInput({ name: "c", type: "float32" })
node.addOutput({ name: "sum", type: "float32" })
\`\`\`
`        }));



        var sumNode = new FlowNode({
            position: {
                x: 850,
                y: 600
            },
            title: "Add",
            info: "I add two numbers",
            inputs: [
                { name: "a", type: "float32" },
                { name: "b", type: "float32" }
            ],
            outputs: [
                { name: "sum", type: "float32" }
            ],
        });


        var aNode = new FlowNode({
            position: {
                x: 550,
                y: 500
            },
            title: "Number",
            info: "I'm a node with a number widget",
            outputs: [
                { name: "value", type: "float32" }
            ],
            widgets: [
                {
                    type: "number",
                    config: { value: 1 }
                }
            ]
        });

        var bNode = new FlowNode({
            position: {
                x: 550,
                y: 650
            },
            title: "Number",
            info: "I'm a node with both a number and image widget on it",
            outputs: [
                { name: "value", type: "float32" }
            ],
            widgets: [
                {
                    type: "number",
                    config: { value: 2 }
                },
                {
                    type: "image",
                    config: {
                        image: "https://i.imgur.com/qRZgWC0.jpeg"
                    }
                }
            ]
        })

        const arrNode = new FlowNode({
            position: {
                x: 1050,
                y: 600
            },
            title: "Add",
            subTitle: "Array Inputs",
            info: "This node contains a port that can take multiple input nodes at once, which can be useful for operations that can operate on [0,n] data sizes",
            inputs: [
                { name: "numbers", type: "float32", array: true },
            ],
            outputs: [
                { name: "sum", type: "float32" }
            ],
        });

        graph.addNode(sumNode)
        graph.addNode(aNode)
        graph.addNode(bNode)
        graph.addNode(arrNode)

        graph.connectNodes(aNode, 0, sumNode, 0)
        graph.connectNodes(bNode, 0, sumNode, 1)

        graph.connectNodes(aNode, 0, arrNode, 0)
        graph.connectNodes(bNode, 0, arrNode, 0)

    </script>
</body>

</html>

================
File: package.json
================
{
  "name": "@elicdavis/node-flow",
  "description": "build node graphs",
  "author": "Eli C Davis",
  "version": "0.1.1",
  "license": "MIT",
  "keywords": [
    "nodes",
    "node-flow",
    "graph"
  ],
  "main": "./dist/index.js",
  "module": "./dist/index.mjs",
  "types": "./dist/index.d.ts",
  "scripts": {
    "build": "ts-node ./esbuild.ts",
    "watch": "npm run build -- --watch",
    "package": "tsup"
  },
  "homepage": "https://github.com/EliCDavis/node-flow",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/EliCDavis/node-flow.git"
  },
  "bugs": {
    "url": "https://github.com/EliCDavis/node-flow/issues"
  },
  "devDependencies": {
    "@esbuild-plugins/node-globals-polyfill": "^0.1.1",
    "@esbuild-plugins/node-modules-polyfill": "^0.1.4",
    "@types/glob": "^7.2.0",
    "@types/mocha": "^9.1.1",
    "@types/node": "16.x",
    "@typescript-eslint/eslint-plugin": "^5.31.0",
    "@typescript-eslint/parser": "^5.31.0",
    "abort-controller": "^3.0.0",
    "esbuild": "^0.15.11",
    "eslint": "^8.20.0",
    "eslint-config-standard": "^17.0.0",
    "eslint-plugin-import": "^2.25.2",
    "eslint-plugin-n": "^15.0.0",
    "eslint-plugin-promise": "^6.0.0",
    "glob": "^8.0.3",
    "mocha": "^10.0.0",
    "stream-browserify": "^3.0.0",
    "ts-node": "^10.9.1",
    "tsup": "^8.4.0",
    "typescript": "^4.7.4"
  }
}

================
File: README.md
================
# Node Flow

Another Flow-based Node graph Library.

Check it out [here](https://elicdavis.github.io/node-flow/).

![promotional image](./docs/promotional-image.png)

## About

Node Flow is a javascript library that enables developers to build node based tools similar to Unreal Blueprints or Blender Nodes. 

## Install

Grab the [latest from npm](https://www.npmjs.com/package/@elicdavis/node-flow):

```
npm i @elicdavis/node-flow
```

Or download the latest build [here](https://raw.githubusercontent.com/EliCDavis/node-flow/gh-pages/dist/web/NodeFlow.js).

## Features

* Nodes
* Markdown Notes
* More Nodes

## Building

If you want to build the library yourself, you can run

```bash
npm run package
```

## API

### Graph API

#### Creation

The only requirement for creating a graph is providing it an instance of a [canvas](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas).

```javascript
import { NodeFlowGraph } from "@elicdavis/node-flow";

// Create a canvas to render our graph to
var canvas = document.createElement("canvas");

// Create our Node Flow Graph
var graph = new NodeFlowGraph(canvas)
```

There are a bunch of optional parameters you can provide the graph:

```javascript
import { NodeFlowGraph } from "@elicdavis/node-flow";
var graph = new NodeFlowGraph(canvas, {
    // Background color of the graph.
    backgroundColor: "#FF5500",

    // You can add extra items to the context
    // menu that pops up when you right click.
    contextMenu: {
        subMenus: [
            {
                // Text that shows up in the context
                // menu 
                name: "Example Context Menu Item",
                
                // This is recursive. We can nest as 
                // many submenus within eachother as
                // we want. This field is optional.
                subMenus: [],

                items: [
                    {
                        name: "Sub menu Item!!!"
                    }
                ]
            }
        ],

        // Items that show up at the base of the 
        // context menu
        items: [
            {
                // Text that shows up in the context
                // menu 
                name: "Example Context Menu Item",
                
                // Function that get's executed when
                // Item is clicked.
                callback: () => {
                    alert("Example Context Menu Item");
                }    
            }
        ]
    },

    // Notes we want rendered on the graph.
    board: {
        notes: [
            {
                // Where to render the note
                position: { x: 20, y: 20 },

                // Whether or not the note can be 
                // interacted with on the graph
                locked: true,

                // Markdown enabled text
                text: `
                # My First note!!!

                Not sure what to write here
                `
            },  
        ]
    },
});
```

### Node API

#### Creation

```javascript
import { FlowNode } from "@elicdavis/node-flow";

// All nodes require a title. That's about it.
var node = new FlowNode({ 
    title: "My First Node!",
});

// Be sure to add it to the graph so it can be rendered.
graph.addNode(node);
```

#### Inputs and Outputs

Create a Add node that takes two numbers and outputs a single number

```javascript
import { FlowNode } from "@elicdavis/node-flow";

var node = new FlowNode({ 
    title: "Add",
    inputs: [
        { name: "a", type: "float32" },
        { name: "b", type: "float32" }
    ],
     outputs: [
        { name: "sum", type: "float32" }
    ],
});
```

You can also add additional inputs and outputs to the node after it's been created

```javascript
node.addInput({ name: "c", type: "float32" })
node.addOutput({ name: "sum", type: "float32" })
```

## Library Development

Just run

```bash
npm run watch
```

================
File: tsconfig.json
================
{
    "compilerOptions": {
        "declaration": true, // Generate .d.ts declaration files
        "sourceMap": true, // Generate source maps (optional)
        "strict": true, // Enable strict type checking (optional)
        "outDir": "./dist/js",
        "target": "ES2015",
    },
    "include": [
        "src/**/*.ts"
    ],
    "exclude": [
        "node_modules"
    ]
}

================
File: tsup.config.ts
================
import { defineConfig } from "tsup";

export default defineConfig({
  entry: ["src/index.ts"],
  format: ["cjs", "esm"], // Build for commonJS and ESmodules
  dts: true, // Generate declaration file (.d.ts)
  // splitting: false,
  sourcemap: true,
  clean: true,
});
